[{"title":"CqjtuSchoolApi","url":"/2022/03/16/CqjtuSchoolApi/","content":"Api教务网登录http://jwgl.cqjtu.edu.cn:80/app.do?method=authUser&amp;xh=xxxx&amp;pwd=xxxxx\n\n参数\n\nxh  //教务网账号 学号pwd //教务网密码\n\n\n返回值(Json)\n\nerror:&#123;&quot;flag&quot;:&quot;0&quot;,&quot;userrealname&quot;:null,&quot;token&quot;:&quot;-1&quot;,&quot;userdwmc&quot;:null,&quot;usertype&quot;:null,&quot;msg&quot;:&quot;账号或密码错误&quot;&#125;success:&#123;&#123;&quot;flag&quot;:&quot;1&quot;,&quot;userrealname&quot;:&quot;xxx&quot;,&quot;token&quot;:&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;,&quot;userdwmc&quot;:&quot;交通运输学院&quot;,&quot;usertype&quot;:&quot;2&quot;,&quot;msg&quot;:&quot;登录成功&quot;&#125;\n\n查询课表‘http://jwgl.cqjtu.edu.cn:80/app.do?method=getKbcx&amp;xh=xxxx&amp;xnxqid=xxxxx&amp;zc=x\n\n参数\n\nxh：  //学号xnxqid： //学年学期 例：2020-2021-2zc  //周次  例：1 2 3 4 5\n\n\n返回值(Json)\n\nerror:&#123;&quot;token&quot;:&quot;-1&quot;&#125;success:[&#123;&quot;jsxm&quot;:&quot;张惠玲&quot;,&quot;jsmc&quot;:&quot;20305&quot;,&quot;jssj&quot;:&quot;10:00&quot;,&quot;kssj&quot;:&quot;08:20&quot;,&quot;kkzc&quot;:&quot;1-8&quot;,&quot;kcsj&quot;:&quot;10102&quot;,&quot;kcmc&quot;:&quot;交通信息检测及处理技术&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;,&#123;&quot;jsxm&quot;:&quot;邓天民&quot;,&quot;jsmc&quot;:&quot;30203&quot;,&quot;jssj&quot;:&quot;15:40&quot;,&quot;kssj&quot;:&quot;14:00&quot;,&quot;kkzc&quot;:&quot;1-8&quot;,&quot;kcsj&quot;:&quot;10506&quot;,&quot;kcmc&quot;:&quot;嵌入式系统基础B&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;,&#123;&quot;jsxm&quot;:&quot;杨林&quot;,&quot;jsmc&quot;:&quot;20410&quot;,&quot;jssj&quot;:&quot;15:40&quot;,&quot;kssj&quot;:&quot;14:00&quot;,&quot;kkzc&quot;:&quot;1-8&quot;,&quot;kcsj&quot;:&quot;20506&quot;,&quot;kcmc&quot;:&quot;交通供配电与照明&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;,&#123;&quot;jsxm&quot;:&quot;张惠玲&quot;,&quot;jsmc&quot;:&quot;20305&quot;,&quot;jssj&quot;:&quot;12:00&quot;,&quot;kssj&quot;:&quot;10:20&quot;,&quot;kkzc&quot;:&quot;1-8&quot;,&quot;kcsj&quot;:&quot;30304&quot;,&quot;kcmc&quot;:&quot;交通信息检测及处理技术&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;,&#123;&quot;jsxm&quot;:&quot;邓天民&quot;,&quot;jsmc&quot;:&quot;20210&quot;,&quot;jssj&quot;:&quot;17:40&quot;,&quot;kssj&quot;:&quot;16:00&quot;,&quot;kkzc&quot;:&quot;1-3,5-8&quot;,&quot;kcsj&quot;:&quot;30708&quot;,&quot;kcmc&quot;:&quot;嵌入式系统基础B&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;,&#123;&quot;jsxm&quot;:&quot;杨林&quot;,&quot;jsmc&quot;:&quot;20410&quot;,&quot;jssj&quot;:&quot;12:00&quot;,&quot;kssj&quot;:&quot;10:20&quot;,&quot;kkzc&quot;:&quot;1-8&quot;,&quot;kcsj&quot;:&quot;40304&quot;,&quot;kcmc&quot;:&quot;交通供配电与照明&quot;,&quot;sjbz&quot;:&quot;0&quot;&#125;]err-args:[]\n\n查询成绩‘http://jwgl.cqjtu.edu.cn:80/app.do?method=getCjcx&amp;xh=xxxxxx&amp;xnxqid=xxxxxxxxx\n\n参数\n\nxh：  //学号xnxqid： //学年学期 例：2020-2021-2\n\n\n返回值(Json)\n\nerror:&#123;&quot;token&quot;:&quot;-1&quot;&#125;success:[&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;选修&quot;,&quot;zcj&quot;:&quot;94&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;轨道交通运营与维护&quot;,&quot;xf&quot;:2.5&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;78&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通工程设施课程设计&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;82&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通供配电与照明&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;选修&quot;,&quot;zcj&quot;:&quot;93&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通规划原理B&quot;,&quot;xf&quot;:3&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;77&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通机电系统&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;80&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通数据分析与处理综合实践&quot;,&quot;xf&quot;:1&#125;,]err-args:[]\n\n查询考试安排http://jwgl.cqjtu.edu.cn:80/app.do?method=getKscx&amp;xh=xxxxxxxx\n\n参数\n\nxh： //学号\n\n\n返回值(Json)\n\nerror:&#123;&quot;token&quot;:&quot;-1&quot;&#125;success:[&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;选修&quot;,&quot;zcj&quot;:&quot;94&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;轨道交通运营与维护&quot;,&quot;xf&quot;:2.5&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;78&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通工程设施课程设计&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;82&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通供配电与照明&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;选修&quot;,&quot;zcj&quot;:&quot;93&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通规划原理B&quot;,&quot;xf&quot;:3&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;77&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通机电系统&quot;,&quot;xf&quot;:2&#125;,&#123;&quot;bz&quot;:null,&quot;cjbsmc&quot;:null,&quot;kclbmc&quot;:&quot;必修&quot;,&quot;zcj&quot;:&quot;80&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;xqmc&quot;:&quot;2020-2021-2&quot;,&quot;kcxzmc&quot;:&quot;专业教育课程&quot;,&quot;kcywmc&quot;:null,&quot;ksxzmc&quot;:&quot;正常考试&quot;,&quot;kcmc&quot;:&quot;交通数据分析与处理综合实践&quot;,&quot;xf&quot;:1&#125;,]err-args:[]\n\n查询学号信息http://jwgl.cqjtu.edu.cn:80/app.do?method=getUserInfo&amp;xh=xxxxxx\n\n参数\n\nxh： //学号\n\n\n返回值(Json)\n\nerror:&#123;&quot;token&quot;:&quot;-1&quot;&#125;success:&#123;&quot;fxzy&quot;:&quot;无&quot;,&quot;xh&quot;:&quot;63180309XXXX&quot;,&quot;xm&quot;:&quot;xxx&quot;,&quot;dqszj&quot;:&quot;2018&quot;,&quot;usertype&quot;:&quot;2&quot;,&quot;yxmc&quot;:&quot;交通运输学院&quot;,&quot;xz&quot;:4,&quot;bj&quot;:&quot;XXX1801班&quot;,&quot;dh&quot;:null,&quot;email&quot;:null,&quot;rxnf&quot;:&quot;2018&quot;,&quot;xb&quot;:&quot;男&quot;,&quot;ksh&quot;:&quot;xxxxxxx&quot;,&quot;nj&quot;:&quot;2018&quot;,&quot;qq&quot;:null,&quot;zymc&quot;:&quot;交通设备与控制工程&quot;&#125;err-args:&#123;&#125;"},{"title":"Markdown基本语法","url":"/2021/07/28/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","content":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n优点：\n\n因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。\n操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可\n\n缺点：\n\n需要记一些语法（当然，是很简单。五分钟学会）\n\n有些平台不支持Markdown编辑模式。\n1. 标题在想要设置为标题的文字前加#几个#符号就是几级标题. #符号后要加空格示例:\n\n\n# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题\n\n效果:\n这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题2. 字体斜体(1个*包裹)加粗(2个*包裹)斜体加粗(3个*包裹)删除线(两个~~包裹)示例:\n**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~\n\n效果:这是加粗的文字这是倾斜的文字&#96;这是斜体加粗的文字这是加删除线的文字\n3. 引用在引用文字前加&gt;即可可嵌套示例:\n&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容\n\n\n这是引用的内容\n\n这是引用的内容\n\n\n\n\n\n这是引用的内容\n\n\n\n\n\n\n\n4. 分割线三个或者三个以上的- 、*示例：\n-------********\n\n5.超链接[超链接名](超链接地址 &quot;超链接title&quot;)\n\ntitile可以不加示例:\n[百度](http://baidu.com)\n\n效果:百度\n6.图片![图片alt](图片地址 &quot;图片title&quot;)\n\n图片alt即图片属性图片title是图片标题,当鼠标移到图片上时显示,可以不加示例:\n![1.png](1.png &quot;champion&quot;)\n\n效果\n7.列表无序列表+、-、*都可以示例:\n+ 列表内容- 列表内容* 列表内容\n\n效果:\n\n列表内容\n\n\n列表内容\n\n\n列表内容\n有序列表数字+.示例\n1. 列表内容2. 列表内容3. 列表内容   \n 效果\n 4. 列表内容5. 列表内容6. 列表内容      #### 列表嵌套      上下级之间敲三个空格      ##### 一级无序、二级无序- 一级    - 二级- 一级    - 二级        ##### 一级有序、二级有序1. 一级      2. 二级2. 一级      2. 二级             ##### 一级无序、二级有序- 一级    2. 二级- 一级    2. 二级           ##### 一级有序、二级无序1. 一级      - 二级2. 一级      - 二级           ### 表格     \n\n\n\n表头\n表头\n表头\n\n\n\n内容\n内容\n内容\n\n\n内容\n内容\n内容\n\n\n          `:`位置确定文本居中方式     `-`有一个即可| 姓名  | 性别  | 年龄  ||:--- |:---:| ---:|| 张三  | 男   | 12  || 李四  | 女   | 13  |### 代码\n\n\n\n\n\n\n代码内容\n单行代码用`` ` ``效果:`代码内容`多行代码用三个`` ` ``包裹起来\n​ 代码内容 代码内容 ​\n效果:\n代码内容代码内容\n\n\n","categories":["常用技巧"],"tags":["常用技巧"]},{"title":"JDBC基础教程","url":"/2021/08/25/JDBC%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","content":"JDBC核心技术讲师：宋红康\n微博：尚硅谷-宋红康\n\n第1章：JDBC概述1.1 数据的持久化\n持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n\n持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n\n1.2 Java中的数据存储技术\n在Java中，数据库存取技术可分为如下几类：\n\nJDBC直接访问数据库\n\nJDO (Java Data Object )技术\n\n第三方O&#x2F;R工具，如Hibernate, Mybatis 等\n\n\n\nJDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。\n\n\n1.3 JDBC介绍\nJDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。\nJDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。\nJDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。\n如果没有JDBC，那么Java程序访问数据库时是这样的：\n\n\n\n\n有了JDBC，Java程序访问数据库时是这样的：\n\n\n\n\n总结如下：\n\n\n1.4 JDBC体系结构\nJDBC接口（API）包括两个层次：\n面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。\n面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。\n\n\n\n\nJDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。\n不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                            ————面向接口编程\n\n1.5 JDBC程序编写步骤\n\n补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。\n\n第2章：获取数据库连接2.1 要素一：Driver接口实现类2.1.1 Driver接口介绍\njava.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。\n\n在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。\n\nOracle的驱动：oracle.jdbc.driver.OracleDriver\nmySql的驱动： com.mysql.jdbc.Driver\n\n\n\n\n\n\n将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。\n\n在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path\n \n注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可\n \n2.1.2 加载与注册JDBC驱动\n加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名\n\nClass.forName(“com.mysql.jdbc.Driver”);\n\n\n注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序\n\n使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动\n\n通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：\n\n\n\n\n2.2 要素二：URL\nJDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。\n\nJDBC URL的标准由三部分组成，各部分间用冒号分隔。 \n\njdbc:子协议:子名称\n协议：JDBC URL中的协议总是jdbc \n子协议：子协议用于标识一个数据库驱动程序\n子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名\n\n\n举例：\n\n几种常用数据库的 JDBC URL\n\nMySQL的连接URL编写方式：\n\njdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）\njdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu?user&#x3D;root&amp;password&#x3D;123456\n\n\nOracle 9i的连接URL编写方式：\n\njdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称\njdbc:oracle:thin:@localhost:1521:atguigu\n\n\nSQLServer的连接URL编写方式：\n\njdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称\n\njdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;atguigu\n\n\n\n\n\n\n2.3 要素三：用户名和密码\nuser,password可以用“属性名&#x3D;属性值”方式告诉数据库\n可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接\n\n2.4 数据库连接方式举例2.4.1 连接方式一@Testpublic void testConnection1() &#123;    try &#123;        //1.提供java.sql.Driver接口实现类的对象        Driver driver = null;        driver = new com.mysql.jdbc.Driver();        //2.提供url，指明具体操作的数据        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        //3.提供Properties的对象，指明用户名和密码        Properties info = new Properties();        info.setProperty(&quot;user&quot;, &quot;root&quot;);        info.setProperty(&quot;password&quot;, &quot;abc123&quot;);        //4.调用driver的connect()，获取连接        Connection conn = driver.connect(url, info);        System.out.println(conn);    &#125; catch (SQLException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n\n说明：上述代码中显式出现了第三方数据库的API\n\n2.4.2 连接方式二@Testpublic void testConnection2() &#123;    try &#123;        //1.实例化Driver        String className = &quot;com.mysql.jdbc.Driver&quot;;        Class clazz = Class.forName(className);        Driver driver = (Driver) clazz.newInstance();        //2.提供url，指明具体操作的数据        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        //3.提供Properties的对象，指明用户名和密码        Properties info = new Properties();        info.setProperty(&quot;user&quot;, &quot;root&quot;);        info.setProperty(&quot;password&quot;, &quot;abc123&quot;);        //4.调用driver的connect()，获取连接        Connection conn = driver.connect(url, info);        System.out.println(conn);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n\n说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。\n\n2.4.3 连接方式三@Testpublic void testConnection3() &#123;    try &#123;        //1.数据库连接的4个基本要素：        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        String user = &quot;root&quot;;        String password = &quot;abc123&quot;;        String driverName = &quot;com.mysql.jdbc.Driver&quot;;        //2.实例化Driver        Class clazz = Class.forName(driverName);        Driver driver = (Driver) clazz.newInstance();        //3.注册驱动        DriverManager.registerDriver(driver);        //4.获取连接        Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n\n说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。\n\n2.4.4 连接方式四@Testpublic void testConnection4() &#123;    try &#123;        //1.数据库连接的4个基本要素：        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;        String user = &quot;root&quot;;        String password = &quot;abc123&quot;;        String driverName = &quot;com.mysql.jdbc.Driver&quot;;        //2.加载驱动 （①实例化Driver ②注册驱动）        Class.forName(driverName);        //Driver driver = (Driver) clazz.newInstance();        //3.注册驱动        //DriverManager.registerDriver(driver);        /*        可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：        static &#123;            try &#123;                DriverManager.registerDriver(new Driver());            &#125; catch (SQLException var1) &#123;                throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);            &#125;        &#125;         */        //3.获取连接        Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;\n\n\n说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。\n\n2.4.5 连接方式五(最终版)@Testpublic  void testConnection5() throws Exception &#123;    //1.加载配置文件    InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);    Properties pros = new Properties();    pros.load(is);    //2.读取配置信息    String user = pros.getProperty(&quot;user&quot;);    String password = pros.getProperty(&quot;password&quot;);    String url = pros.getProperty(&quot;url&quot;);    String driverClass = pros.getProperty(&quot;driverClass&quot;);    //3.加载驱动    Class.forName(driverClass);    //4.获取连接    Connection conn = DriverManager.getConnection(url,user,password);    System.out.println(conn);&#125;\n\n其中，配置文件声明在工程的src目录下：【jdbc.properties】\nuser=rootpassword=abc123url=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver\n\n\n说明：使用配置文件的方式保存配置信息，在代码中加载配置文件\n使用配置文件的好处：\n①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。\n\n第3章：使用PreparedStatement实现CRUD操作3.1 操作和访问数据库\n数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。\n\n在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：\n\nStatement：用于执行静态 SQL 语句并返回它所生成结果的对象。 \nPrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。\nCallableStatement：用于执行 SQL 存储过程\n\n\n\n\n3.2 使用Statement操作数据表的弊端\n通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。\n\nStatement 接口中定义了下列方法用于执行 SQL 语句：\nint excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT\n\n但是使用Statement操作数据表存在弊端：\n\n问题一：存在拼串操作，繁琐\n问题二：存在SQL注入问题\n\n\nSQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。\n\n对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。\n\n代码演示：\n\n\npublic class StatementTest &#123;    // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题    @Test    public void testLogin() &#123;        Scanner scan = new Scanner(System.in);        System.out.print(&quot;用户名：&quot;);        String userName = scan.nextLine();        System.out.print(&quot;密   码：&quot;);        String password = scan.nextLine();        // SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;        String sql = &quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot; + userName + &quot;&#x27; AND PASSWORD = &#x27;&quot; + password                + &quot;&#x27;&quot;;        User user = get(sql, User.class);        if (user != null) &#123;            System.out.println(&quot;登陆成功!&quot;);        &#125; else &#123;            System.out.println(&quot;用户名或密码错误！&quot;);        &#125;    &#125;    // 使用Statement实现对数据表的查询操作    public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) &#123;        T t = null;        Connection conn = null;        Statement st = null;        ResultSet rs = null;        try &#123;            // 1.加载配置文件            InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);            Properties pros = new Properties();            pros.load(is);            // 2.读取配置信息            String user = pros.getProperty(&quot;user&quot;);            String password = pros.getProperty(&quot;password&quot;);            String url = pros.getProperty(&quot;url&quot;);            String driverClass = pros.getProperty(&quot;driverClass&quot;);            // 3.加载驱动            Class.forName(driverClass);            // 4.获取连接            conn = DriverManager.getConnection(url, user, password);            st = conn.createStatement();            rs = st.executeQuery(sql);            // 获取结果集的元数据            ResultSetMetaData rsmd = rs.getMetaData();            // 获取结果集的列数            int columnCount = rsmd.getColumnCount();            if (rs.next()) &#123;                t = clazz.newInstance();                for (int i = 0; i &lt; columnCount; i++) &#123;                    // //1. 获取列的名称                    // String columnName = rsmd.getColumnName(i+1);                    // 1. 获取列的别名                    String columnName = rsmd.getColumnLabel(i + 1);                    // 2. 根据列名获取对应数据表中的数据                    Object columnVal = rs.getObject(columnName);                    // 3. 将数据表中得到的数据，封装进对象                    Field field = clazz.getDeclaredField(columnName);                    field.setAccessible(true);                    field.set(t, columnVal);                &#125;                return t;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 关闭资源            if (rs != null) &#123;                try &#123;                    rs.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (st != null) &#123;                try &#123;                    st.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (conn != null) &#123;                try &#123;                    conn.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        return null;    &#125;&#125;\n\n综上：\n\n3.3 PreparedStatement的使用3.3.1 PreparedStatement介绍\n可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象\n\nPreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句\n\nPreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值\n\n\n3.3.2 PreparedStatement vs Statement\n代码的可读性和可维护性。\n\nPreparedStatement 能最大可能提高性能：\n\nDBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。\n在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。\n(语法检查，语义检查，翻译成二进制命令，缓存)\n\n\nPreparedStatement 可以防止 SQL 注入\n\n\n3.3.3 Java与SQL对应数据类型转换表\n\n\nJava类型\nSQL类型\n\n\n\nboolean\nBIT\n\n\nbyte\nTINYINT\n\n\nshort\nSMALLINT\n\n\nint\nINTEGER\n\n\nlong\nBIGINT\n\n\nString\nCHAR,VARCHAR,LONGVARCHAR\n\n\nbyte   array\nBINARY  ,    VAR BINARY\n\n\njava.sql.Date\nDATE\n\n\njava.sql.Time\nTIME\n\n\njava.sql.Timestamp\nTIMESTAMP\n\n\n3.3.4 使用PreparedStatement实现增、删、改操作//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）public void update(String sql,Object ... args)&#123;    Connection conn = null;    PreparedStatement ps = null;    try &#123;        //1.获取数据库的连接        conn = JDBCUtils.getConnection();        //2.获取PreparedStatement的实例 (或：预编译sql语句)        ps = conn.prepareStatement(sql);        //3.填充占位符        for(int i = 0;i &lt; args.length;i++)&#123;            ps.setObject(i + 1, args[i]);        &#125;        //4.执行sql语句        ps.execute();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;finally&#123;        //5.关闭资源        JDBCUtils.closeResource(conn, ps);    &#125;&#125;\n\n\n\n3.3.5 使用PreparedStatement实现查询操作// 通用的针对于不同表的查询:返回一个对象 (version 1.0)public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;    Connection conn = null;    PreparedStatement ps = null;    ResultSet rs = null;    try &#123;        // 1.获取数据库连接        conn = JDBCUtils.getConnection();        // 2.预编译sql语句，得到PreparedStatement对象        ps = conn.prepareStatement(sql);        // 3.填充占位符        for (int i = 0; i &lt; args.length; i++) &#123;            ps.setObject(i + 1, args[i]);        &#125;        // 4.执行executeQuery(),得到结果集：ResultSet        rs = ps.executeQuery();        // 5.得到结果集的元数据：ResultSetMetaData        ResultSetMetaData rsmd = rs.getMetaData();        // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值        int columnCount = rsmd.getColumnCount();        if (rs.next()) &#123;            T t = clazz.newInstance();            for (int i = 0; i &lt; columnCount; i++) &#123;// 遍历每一个列                // 获取列值                Object columnVal = rs.getObject(i + 1);                // 获取列的别名:列的别名，使用类的属性名充当                String columnLabel = rsmd.getColumnLabel(i + 1);                // 6.2使用反射，给对象的相应属性赋值                Field field = clazz.getDeclaredField(columnLabel);                field.setAccessible(true);                field.set(t, columnVal);            &#125;            return t;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        // 7.关闭资源        JDBCUtils.closeResource(conn, ps, rs);    &#125;    return null;&#125;\n\n\n说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。\n\n3.4 ResultSet与ResultSetMetaData3.4.1 ResultSet\n查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象\n\nResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现\n\nResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。\n\nResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。\n\n当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。\n\n例如: getInt(1), getString(“name”)\n注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。\n\n\nResultSet 接口的常用方法：\n\nboolean next()\n\ngetString()\n\n…\n\n\n\n\n\n3.4.2 ResultSetMetaData\n可用于获取关于 ResultSet 对象中列的类型和属性信息的对象\n\nResultSetMetaData meta &#x3D; rs.getMetaData();\n\ngetColumnName(int column)：获取指定列的名称\n\ngetColumnLabel(int column)：获取指定列的别名\n\ngetColumnCount()：返回当前 ResultSet 对象中的列数。 \n\ngetColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 \n\ngetColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 \n\nisNullable(int column)：指示指定列中的值是否可以为 null。 \n\nisAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。\n\n\n\n\n\n问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？\n​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData\n问题2：关于ResultSetMetaData\n\n如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可\n获取 ResultSet 中有多少列：调用 ResultSetMetaData 的 getColumnCount() 方法\n获取 ResultSet 每一列的列的别名是什么：调用 ResultSetMetaData 的getColumnLabel() 方法\n\n\n3.5 资源的释放\n释放ResultSet, Statement,Connection。\n数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。\n可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。\n\n3.6 JDBC API小结\n两种思想\n\n面向接口编程的思想\n\nORM思想(object relational mapping)\n\n一个数据表对应一个java类\n表中的一条记录对应java类的一个对象\n表中的一个字段对应java类的一个属性\n\n\n\n\nsql是需要结合列名和表的属性名来写。注意起别名。\n\n\n两种技术\n\nJDBC结果集的元数据：ResultSetMetaData\n获取列数：getColumnCount()\n获取列的别名：getColumnLabel()\n\n\n通过反射，创建指定类的对象，获取指定的属性并赋值\n\n\n\n\n章节练习练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：\n\n练习题2：创立数据库表 examstudent，表结构如下：\n\n向数据表中添加如下数据：\n\n代码实现1：插入一个新的student 信息\n请输入考生的详细信息\nType:IDCard:ExamCard:StudentName:Location:Grade:\n信息录入成功!\n代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：\n\n代码实现3：完成学生信息的删除功能\n\n\n第4章 操作BLOB类型字段4.1 MySQL BLOB类型\nMySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。\n\n插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。\n\nMySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)\n\n\n\n\n实际使用中根据需要存入的数据大小定义不同的BLOB类型。\n需要注意的是：如果存储的文件过大，数据库的性能会下降。\n如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。\n\n4.2 向数据表中插入大数据类型//获取连接Connection conn = JDBCUtils.getConnection();String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符ps.setString(1, &quot;徐海强&quot;);ps.setString(2, &quot;xhq@126.com&quot;);ps.setDate(3, new Date(new java.util.Date().getTime()));// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;xhq.png&quot;);ps.setBlob(4, fis);//执行ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);\n\n\n\n4.3 修改数据表中的Blob类型字段Connection conn = JDBCUtils.getConnection();String sql = &quot;update customers set photo = ? where id = ?&quot;;PreparedStatement ps = conn.prepareStatement(sql);// 填充占位符// 操作Blob类型的变量FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;);ps.setBlob(1, fis);ps.setInt(2, 25);ps.execute();fis.close();JDBCUtils.closeResource(conn, ps);\n\n\n\n4.4 从数据表中读取大数据类型String sql = &quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;;conn = getConnection();ps = conn.prepareStatement(sql);ps.setInt(1, 8);rs = ps.executeQuery();if(rs.next())&#123;    Integer id = rs.getInt(1);    String name = rs.getString(2);    String email = rs.getString(3);    Date birth = rs.getDate(4);    Customer cust = new Customer(id, name, email, birth);    System.out.println(cust);     //读取Blob类型的字段    Blob photo = rs.getBlob(5);    InputStream is = photo.getBinaryStream();    OutputStream os = new FileOutputStream(&quot;c.jpg&quot;);    byte [] buffer = new byte[1024];    int len = 0;    while((len = is.read(buffer)) != -1)&#123;        os.write(buffer, 0, len);    &#125;    JDBCUtils.closeResource(conn, ps, rs);    if(is != null)&#123;        is.close();    &#125;    if(os !=  null)&#123;        os.close();    &#125;&#125;\n\n\n\n第5章 批量插入5.1 批量执行SQL语句当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率\nJDBC的批量处理语句包括下面三个方法：\n\naddBatch(String)：添加需要批量处理的SQL语句或是参数；\nexecuteBatch()：执行批量处理语句；\nclearBatch():清空缓存的数据\n\n通常我们会遇到两种批量执行SQL语句的情况：\n\n多条SQL语句的批量处理；\n一个SQL语句的批量传参；\n\n5.2 高效的批量插入举例：向数据表中插入20000条数据\n\n数据库中提供一个goods表。创建如下：\n\nCREATE TABLE goods(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20));\n\n\n\n5.2.1 实现层次一：使用StatementConnection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++)&#123;    String sql = &quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;+ i +&quot;)&quot;;    st.executeUpdate(sql);&#125;\n\n\n\n5.2.2 实现层次二：使用PreparedStatementlong start = System.currentTimeMillis();Connection conn = JDBCUtils.getConnection();String sql = &quot;insert into goods(name)values(?)&quot;;PreparedStatement ps = conn.prepareStatement(sql);for(int i = 1;i &lt;= 20000;i++)&#123;    ps.setString(1, &quot;name_&quot; + i);    ps.executeUpdate();&#125;long end = System.currentTimeMillis();System.out.println(&quot;花费的时间为：&quot; + (end - start));//82340JDBCUtils.closeResource(conn, ps);\n\n5.2.3 实现层次三/* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 *          ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar *  */@Testpublic void testInsert1() throws Exception&#123;    long start = System.currentTimeMillis();    Connection conn = JDBCUtils.getConnection();    String sql = &quot;insert into goods(name)values(?)&quot;;    PreparedStatement ps = conn.prepareStatement(sql);    for(int i = 1;i &lt;= 1000000;i++)&#123;        ps.setString(1, &quot;name_&quot; + i);        //1.“攒”sql        ps.addBatch();        if(i % 500 == 0)&#123;            //2.执行            ps.executeBatch();            //3.清空            ps.clearBatch();        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625                                                                         //1000000条:14733      JDBCUtils.closeResource(conn, ps);&#125;\n\n5.2.4 实现层次四/** 层次四：在层次三的基础上操作* 使用Connection 的 setAutoCommit(false)  /  commit()*/@Testpublic void testInsert2() throws Exception&#123;    long start = System.currentTimeMillis();    Connection conn = JDBCUtils.getConnection();    //1.设置为不自动提交数据    conn.setAutoCommit(false);    String sql = &quot;insert into goods(name)values(?)&quot;;    PreparedStatement ps = conn.prepareStatement(sql);    for(int i = 1;i &lt;= 1000000;i++)&#123;        ps.setString(1, &quot;name_&quot; + i);        //1.“攒”sql        ps.addBatch();        if(i % 500 == 0)&#123;            //2.执行            ps.executeBatch();            //3.清空            ps.clearBatch();        &#125;    &#125;    //2.提交数据    conn.commit();    long end = System.currentTimeMillis();    System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978     JDBCUtils.closeResource(conn, ps);&#125;\n\n\n\n第6章： 数据库事务6.1 数据库事务介绍\n事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。\n\n事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。\n\n为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。\n\n\n6.2 JDBC事务处理\n数据一旦提交，就不可回滚。\n\n数据什么时候意味着提交？\n\n当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。\n关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。\n\n\nJDBC程序中为了让多个 SQL 语句作为一个事务执行：\n\n调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务\n在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务\n在出现异常时，调用 rollback(); 方法回滚事务\n\n\n若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。\n\n\n\n【案例：用户AA向用户BB转账100】\npublic void testJDBCTransaction() &#123;    Connection conn = null;    try &#123;        // 1.获取数据库连接        conn = JDBCUtils.getConnection();        // 2.开启事务        conn.setAutoCommit(false);        // 3.进行数据库操作        String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;;        update(conn, sql1, &quot;AA&quot;);        // 模拟网络异常        //System.out.println(10 / 0);        String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;;        update(conn, sql2, &quot;BB&quot;);        // 4.若没有异常，则提交事务        conn.commit();    &#125; catch (Exception e) &#123;        e.printStackTrace();        // 5.若有异常，则回滚事务        try &#123;            conn.rollback();        &#125; catch (SQLException e1) &#123;            e1.printStackTrace();        &#125;    &#125; finally &#123;        try &#123;            //6.恢复每次DML操作的自动提交功能            conn.setAutoCommit(true);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        //7.关闭连接        JDBCUtils.closeResource(conn, null, null);     &#125;  &#125;\n\n其中，对数据库操作的方法为：\n//使用事务以后的通用的增删改操作（version 2.0）public void update(Connection conn ,String sql, Object... args) &#123;    PreparedStatement ps = null;    try &#123;        // 1.获取PreparedStatement的实例 (或：预编译sql语句)        ps = conn.prepareStatement(sql);        // 2.填充占位符        for (int i = 0; i &lt; args.length; i++) &#123;            ps.setObject(i + 1, args[i]);        &#125;        // 3.执行sql语句        ps.execute();    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        // 4.关闭资源        JDBCUtils.closeResource(null, ps);    &#125;&#125;\n\n\n\n6.3 事务的ACID属性\n原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 \n\n一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。\n\n隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。\n\n\n6.3.1 数据库的并发问题\n对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:\n\n脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。\n不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。\n幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n\n数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。\n\n一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\n\n6.3.2 四种隔离级别\n数据库提供的4种事务隔离级别：\n\nOracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。\n\nMysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。\n\n\n6.3.3 在MySql中设置隔离级别\n每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。\n\n查看当前的隔离级别: \nSELECT @@tx_isolation;\n\n设置当前 mySQL 连接的隔离级别:  \nset  transaction isolation level read committed;\n\n设置数据库系统的全局的隔离级别:\nset global transaction isolation level read committed;\n\n补充操作：\n\n创建mysql数据库用户：\ncreate user tom identified by &#x27;abc123&#x27;;\n\n授予权限\n#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;;  #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; \n\n\n\n第7章：DAO及相关实现类\nDAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO\n作用：为了实现功能的模块化，更有利于代码的维护和升级。\n下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：\n\n\n\n层次结构：\n\n\n【BaseDAO.java】package com.atguigu.bookstore.dao;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;/** * 定义一个用来被继承的对数据库进行基本操作的Dao *  * @author HanYanBing * * @param &lt;T&gt; */public abstract class BaseDao&lt;T&gt; &#123;    private QueryRunner queryRunner = new QueryRunner();    // 定义一个变量来接收泛型的类型    private Class&lt;T&gt; type;    // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定    public BaseDao() &#123;        // 获取子类的类型        Class clazz = this.getClass();        // 获取父类的类型        // getGenericSuperclass()用来获取当前类的父类的类型        // ParameterizedType表示的是带泛型的类型        ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();        // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型        // 这个方法会返回一个Type的数组        Type[] types = parameterizedType.getActualTypeArguments();        // 获取具体的泛型的类型·        this.type = (Class&lt;T&gt;) types[0];    &#125;    /**     * 通用的增删改操作     *      * @param sql     * @param params     * @return     */    public int update(Connection conn,String sql, Object... params) &#123;        int count = 0;        try &#123;            count = queryRunner.update(conn, sql, params);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;         return count;    &#125;    /**     * 获取一个对象     *      * @param sql     * @param params     * @return     */    public T getBean(Connection conn,String sql, Object... params) &#123;        T t = null;        try &#123;            t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;         return t;    &#125;    /**     * 获取所有对象     *      * @param sql     * @param params     * @return     */    public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) &#123;        List&lt;T&gt; list = null;        try &#123;            list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;         return list;    &#125;    /**     * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句     *      * @param sql     * @param params     * @return     */    public Object getValue(Connection conn,String sql, Object... params) &#123;        Object count = null;        try &#123;            // 调用queryRunner的query方法获取一个单一的值            count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params);        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;         return count;    &#125;&#125;\n\n【BookDAO.java】package com.atguigu.bookstore.dao;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;public interface BookDao &#123;    /**     * 从数据库中查询出所有的记录     *      * @return     */    List&lt;Book&gt; getBooks(Connection conn);    /**     * 向数据库中插入一条记录     *      * @param book     */    void saveBook(Connection conn,Book book);    /**     * 从数据库中根据图书的id删除一条记录     *      * @param bookId     */    void deleteBookById(Connection conn,String bookId);    /**     * 根据图书的id从数据库中查询出一条记录     *      * @param bookId     * @return     */    Book getBookById(Connection conn,String bookId);    /**     * 根据图书的id从数据库中更新一条记录     *      * @param book     */    void updateBook(Connection conn,Book book);    /**     * 获取带分页的图书信息     *      * @param page：是只包含了用户输入的pageNo属性的page对象     * @return 返回的Page对象是包含了所有属性的Page对象     */    Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page);    /**     * 获取带分页和价格范围的图书信息     *      * @param page：是只包含了用户输入的pageNo属性的page对象     * @return 返回的Page对象是包含了所有属性的Page对象     */    Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice);&#125;\n\n【UserDAO.java】package com.atguigu.bookstore.dao;import java.sql.Connection;import com.atguigu.bookstore.beans.User;public interface UserDao &#123;    /**     * 根据User对象中的用户名和密码从数据库中获取一条记录     *      * @param user     * @return User 数据库中有记录 null 数据库中无此记录     */    User getUser(Connection conn,User user);    /**     * 根据User对象中的用户名从数据库中获取一条记录     *      * @param user     * @return true 数据库中有记录 false 数据库中无此记录     */    boolean checkUsername(Connection conn,User user);    /**     * 向数据库中插入User对象     *      * @param user     */    void saveUser(Connection conn,User user);&#125;\n\n【BookDaoImpl.java】package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import java.util.List;import com.atguigu.bookstore.beans.Book;import com.atguigu.bookstore.beans.Page;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.BookDao;public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao &#123;    @Override    public List&lt;Book&gt; getBooks(Connection conn) &#123;        // 调用BaseDao中得到一个List的方法        List&lt;Book&gt; beanList = null;        // 写sql语句        String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;;        beanList = getBeanList(conn,sql);        return beanList;    &#125;    @Override    public void saveBook(Connection conn,Book book) &#123;        // 写sql语句        String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;;        // 调用BaseDao中通用的增删改的方法        update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());    &#125;    @Override    public void deleteBookById(Connection conn,String bookId) &#123;        // 写sql语句        String sql = &quot;DELETE FROM books WHERE id = ?&quot;;        // 调用BaseDao中通用增删改的方法        update(conn,sql, bookId);    &#125;    @Override    public Book getBookById(Connection conn,String bookId) &#123;        // 调用BaseDao中获取一个对象的方法        Book book = null;        // 写sql语句        String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;;        book = getBean(conn,sql, bookId);        return book;    &#125;    @Override    public void updateBook(Connection conn,Book book) &#123;        // 写sql语句        String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;;        // 调用BaseDao中通用的增删改的方法        update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());    &#125;    @Override    public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) &#123;        // 获取数据库中图书的总记录数        String sql = &quot;select count(*) from books&quot;;        // 调用BaseDao中获取一个单一值的方法        long totalRecord = (long) getValue(conn,sql);        // 将总记录数设置都page对象中        page.setTotalRecord((int) totalRecord);        // 获取当前页中的记录存放的List        String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;;        // 调用BaseDao中获取一个集合的方法        List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);        // 将这个List设置到page对象中        page.setList(beanList);        return page;    &#125;    @Override    public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) &#123;        // 获取数据库中图书的总记录数        String sql = &quot;select count(*) from books where price between ? and ?&quot;;        // 调用BaseDao中获取一个单一值的方法        long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice);        // 将总记录数设置都page对象中        page.setTotalRecord((int) totalRecord);        // 获取当前页中的记录存放的List        String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;;        // 调用BaseDao中获取一个集合的方法        List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE);        // 将这个List设置到page对象中        page.setList(beanList);        return page;    &#125;&#125;\n\n【UserDaoImpl.java】package com.atguigu.bookstore.dao.impl;import java.sql.Connection;import com.atguigu.bookstore.beans.User;import com.atguigu.bookstore.dao.BaseDao;import com.atguigu.bookstore.dao.UserDao;public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao &#123;    @Override    public User getUser(Connection conn,User user) &#123;        // 调用BaseDao中获取一个对象的方法        User bean = null;        // 写sql语句        String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;;        bean = getBean(conn,sql, user.getUsername(), user.getPassword());        return bean;    &#125;    @Override    public boolean checkUsername(Connection conn,User user) &#123;        // 调用BaseDao中获取一个对象的方法        User bean = null;        // 写sql语句        String sql = &quot;select id,username,password,email from users where username = ?&quot;;        bean = getBean(conn,sql, user.getUsername());        return bean != null;    &#125;    @Override    public void saveUser(Connection conn,User user) &#123;        //写sql语句        String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;;        //调用BaseDao中通用的增删改的方法        update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());    &#125;&#125;\n\n【Book.java】package com.atguigu.bookstore.beans;/** * 图书类 * @author songhongkang * */public class Book &#123;    private Integer id;    private String title; // 书名    private String author; // 作者    private double price; // 价格    private Integer sales; // 销量    private Integer stock; // 库存    private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径    //构造器，get()，set()，toString()方法略&#125;\n\n【Page.java】package com.atguigu.bookstore.beans;import java.util.List;/** * 页码类 * @author songhongkang * */public class Page&lt;T&gt; &#123;    private List&lt;T&gt; list; // 每页查到的记录存放的集合    public static final int PAGE_SIZE = 4; // 每页显示的记录数    private int pageNo; // 当前页//    private int totalPageNo; // 总页数，通过计算得到    private int totalRecord; // 总记录数，通过查询数据库得到\n\n【User.java】package com.atguigu.bookstore.beans;/** * 用户类 * @author songhongkang * */public class User &#123;    private Integer id;    private String username;    private String password;    private String email;\n\n\n\n第8章：数据库连接池8.1 JDBC数据库连接池的必要性\n在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　\n\n在主程序（如servlet、beans）中建立数据库连接\n进行sql操作\n断开数据库连接\n\n\n这种模式开发，存在的问题:\n\n普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。\n对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）\n这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。\n\n\n\n8.2 数据库连接池技术\n为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。\n\n数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。\n\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。\n\n数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。\n\n\n\n\n工作原理：\n\n\n\n数据库连接池技术的优点1. 资源重用由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。2. 更快的系统反应速度数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间3. 新的资源分配手段对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源4. 统一的连接管理，避免数据库连接泄漏在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露\n\n8.3 多种开源的数据库连接池\nJDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：\nDBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。\nC3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用\nProxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点\nBoneCP 是一个开源组织提供的数据库连接池，速度快\nDruid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快\n\n\nDataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池\nDataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。\n特别注意：\n数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。\n当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n\n\n\n8.3.1 C3P0数据库连接池\n获取连接方式一\n\n//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐public static Connection getConnection1() throws Exception&#123;    ComboPooledDataSource cpds = new ComboPooledDataSource();    cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);     cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);    cpds.setUser(&quot;root&quot;);    cpds.setPassword(&quot;abc123&quot;);//    cpds.setMaxPoolSize(100);    Connection conn = cpds.getConnection();    return conn;&#125;\n\n\n\n\n获取连接方式二\n\n//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;);public static Connection getConnection2() throws SQLException&#123;    Connection conn = cpds.getConnection();    return conn;&#125;\n\n其中，src下的配置文件为：【c3p0-config.xml】\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt;    &lt;named-config name=&quot;helloc3p0&quot;&gt;        &lt;!-- 获取连接的4个基本信息 --&gt;        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt;        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt;        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;        &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;        &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;        &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt;        &lt;!-- 初始化数据库连接池时连接的数量 --&gt;        &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt;        &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;        &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt;        &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;        &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt;        &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;        &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt;        &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;        &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;    &lt;/named-config&gt;&lt;/c3p0-config&gt;\n\n\n\n8.3.2 DBCP数据库连接池\nDBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：\nCommons-dbcp.jar：连接池的实现\nCommons-pool.jar：连接池实现的依赖库\n\n\nTomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。\n数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。\n当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。\n配置属性说明\n\n\n\n\n属性\n默认值\n说明\n\n\n\ninitialSize\n0\n连接池启动时创建的初始化连接数量\n\n\nmaxActive\n8\n连接池中可同时连接的最大的连接数\n\n\nmaxIdle\n8\n连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制\n\n\nminIdle\n0\n连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。\n\n\nmaxWait\n无限制\n最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待\n\n\npoolPreparedStatements\nfalse\n开启池的Statement是否prepared\n\n\nmaxOpenPreparedStatements\n无限制\n开启池的prepared 后的同时最大连接数\n\n\nminEvictableIdleTimeMillis\n\n连接池中连接，在时间段内一直空闲， 被逐出连接池的时间\n\n\nremoveAbandonedTimeout\n300\n超过时间限制，回收没有用(废弃)的连接\n\n\nremoveAbandoned\nfalse\n超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收\n\n\n\n获取连接方式一：\n\npublic static Connection getConnection3() throws Exception &#123;    BasicDataSource source = new BasicDataSource();    source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);    source.setUrl(&quot;jdbc:mysql:///test&quot;);    source.setUsername(&quot;root&quot;);    source.setPassword(&quot;abc123&quot;);    //    source.setInitialSize(10);    Connection conn = source.getConnection();    return conn;&#125;\n\n\n获取连接方式二：\n\n//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static&#123;    try &#123;        Properties pros = new Properties();        InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;);        pros.load(is);        //根据提供的BasicDataSourceFactory创建对应的DataSource对象        source = BasicDataSourceFactory.createDataSource(pros);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;public static Connection getConnection4() throws Exception &#123;    Connection conn = source.getConnection();    return conn;&#125;\n\n其中，src下的配置文件为：【dbcp.properties】\ndriverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#...\n\n\n\n8.3.3 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。\npackage com.atguigu.druid;import java.sql.Connection;import java.util.Properties;import javax.sql.DataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;public class TestDruid &#123;    public static void main(String[] args) throws Exception &#123;        Properties pro = new Properties();         pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        Connection conn = ds.getConnection();        System.out.println(conn);    &#125;&#125;\n\n其中，src下的配置文件为：【druid.properties】\nurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=123456driverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=20maxWait=1000filters=wall\n\n\n详细配置参数：\n\n\n\n\n配置\n缺省\n说明\n\n\n\nname\n\n配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)\n\n\nurl\n\n连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto\n\n\nusername\n\n连接数据库的用户名\n\n\npassword\n\n连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\n\n\ndriverClassName\n\n根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)\n\n\ninitialSize\n0\n初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\n\n\nmaxActive\n8\n最大连接池数量\n\n\nmaxIdle\n8\n已经不再使用，配置了也没效果\n\n\nminIdle\n\n最小连接池数量\n\n\nmaxWait\n\n获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n\n\npoolPreparedStatements\nfalse\n是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。\n\n\nmaxOpenPreparedStatements\n-1\n要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n\n\nvalidationQuery\n\n用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。\n\n\ntestOnBorrow\ntrue\n申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n\n\ntestOnReturn\nfalse\n归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n\n\ntestWhileIdle\nfalse\n建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n\n\ntimeBetweenEvictionRunsMillis\n\n有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明\n\n\nnumTestsPerEvictionRun\n\n不再使用，一个DruidDataSource只支持一个EvictionRun\n\n\nminEvictableIdleTimeMillis\n\n\n\n\nconnectionInitSqls\n\n物理连接初始化的时候执行的sql\n\n\nexceptionSorter\n\n根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接\n\n\nfilters\n\n属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall\n\n\nproxyFilters\n\n类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系\n\n\n第9章：Apache-DBUtils实现CRUD操作9.1 Apache-DBUtils简介\ncommons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。\n\nAPI介绍：\n\norg.apache.commons.dbutils.QueryRunner\norg.apache.commons.dbutils.ResultSetHandler\n工具类：org.apache.commons.dbutils.DbUtils\n\n\nAPI包说明：\n\n\n\n\n9.2 主要API的使用9.2.1 DbUtils\nDbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：\npublic static void close(…) throws java.sql.SQLException：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。\npublic static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。\npublic static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接\npublic static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 \npublic static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断\npublic static void rollbackAndClose(Connection conn)throws SQLException\nrollbackAndCloseQuietly(Connection)\npublic static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。\n\n\n\n9.2.2 QueryRunner类\n该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。\n\nQueryRunner类提供了两个构造器：\n\n默认的构造器\n需要一个 javax.sql.DataSource 来作参数的构造器\n\n\nQueryRunner类的主要方法：\n\n更新\npublic int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。\n……\n\n\n插入\npublic  T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值\n….\n\n\n批处理\npublic int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句\npublic  T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句\n…..\n\n\n查询\npublic Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。\n……\n\n\n\n\n测试\n\n\n// 测试添加@Testpublic void testInsert() throws Exception &#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;;    int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;);    System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;);    JDBCUtils.closeResource(conn, null);&#125;\n\n// 测试删除@Testpublic void testDelete() throws Exception &#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    String sql = &quot;delete from customers where id &lt; ?&quot;;    int count = runner.update(conn, sql,3);    System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;);    JDBCUtils.closeResource(conn, null);&#125;\n\n\n\n9.2.3 ResultSetHandler接口及实现类\n该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\n\nResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。\n\n接口的主要实现类：\n\nArrayHandler：把结果集中的第一行数据转成对象数组。\nArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。\nBeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。\nBeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\nColumnListHandler：将结果集中某一列的数据存放到List中。\nKeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。\nMapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\nMapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List\nScalarHandler：查询单个值对象\n\n\n测试\n\n\n/* * 测试查询:查询一条记录 *  * 使用ResultSetHandler的实现类：BeanHandler */@Testpublic void testQueryInstance() throws Exception&#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;    //    BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class);    Customer customer = runner.query(conn, sql, handler, 23);    System.out.println(customer);        JDBCUtils.closeResource(conn, null);&#125;\n\n/* * 测试查询:查询多条记录构成的集合 *  * 使用ResultSetHandler的实现类：BeanListHandler */@Testpublic void testQueryList() throws Exception&#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;;    //    BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class);    List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23);    list.forEach(System.out::println);    JDBCUtils.closeResource(conn, null);&#125;\n\n/* * 自定义ResultSetHandler的实现类 */@Testpublic void testQueryInstance1() throws Exception&#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;    ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() &#123;        @Override        public Customer handle(ResultSet rs) throws SQLException &#123;            System.out.println(&quot;handle&quot;);//            return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));            if(rs.next())&#123;                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                String email = rs.getString(&quot;email&quot;);                Date birth = rs.getDate(&quot;birth&quot;);                return new Customer(id, name, email, birth);            &#125;            return null;        &#125;    &#125;;    Customer customer = runner.query(conn, sql, handler, 23);    System.out.println(customer);    JDBCUtils.closeResource(conn, null);&#125;\n\n/* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler *  */@Testpublic void testQueryValue() throws Exception&#123;    QueryRunner runner = new QueryRunner();    Connection conn = JDBCUtils.getConnection3();    //测试一：//    String sql = &quot;select count(*) from customers where id &lt; ?&quot;;//    ScalarHandler handler = new ScalarHandler();//    long count = (long) runner.query(conn, sql, handler, 20);//    System.out.println(count);    //测试二：    String sql = &quot;select max(birth) from customers&quot;;    ScalarHandler handler = new ScalarHandler();    Date birth = (Date) runner.query(conn, sql, handler);    System.out.println(birth);    JDBCUtils.closeResource(conn, null);&#125;\n\nJDBC总结总结@Testpublic void testUpdateWithTx() &#123;    Connection conn = null;    try &#123;        //1.获取连接的操作（        //① 手写的连接：JDBCUtils.getConnection();        //② 使用数据库连接池：C3P0;DBCP;Druid        //2.对数据表进行一系列CRUD操作        //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;        //② 使用dbutils提供的jar包中提供的QueryRunner类        //提交数据        conn.commit();    &#125; catch (Exception e) &#123;        e.printStackTrace();        try &#123;            //回滚数据            conn.rollback();        &#125; catch (SQLException e1) &#123;            e1.printStackTrace();        &#125;    &#125;finally&#123;        //3.关闭连接等操作        //① JDBCUtils.closeResource();        //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作    &#125;&#125;\n"},{"title":"centos7下部署flask-Nginx-Gunicorn","url":"/2021/07/28/centos7%E4%B8%8B%E9%83%A8%E7%BD%B2flask-Nginx-Gunicorn/","content":"centos7下部署flask-Nginx-Gunicorn步骤如下1.下载gunicorn直接使用命令:\n$ pip3 install gunicorn\n\n同时把flask也下载了:\n$ pip3 install flask\n\n注: 没有使用pip,因为选的是华为云服务器centos7，自带的python为2.7版本，但是同样有python 3.6版本，需要使用python3来唤起，所以我就直接用的pip3。\n2.将gunicorn加入到app.run()中我在&#x2F;tmp&#x2F;flask_test下新建了app.py作为入口函数。 (其实我是直接在Windows下写好代码在传输到服务器上，flask_test目录下同时还有目录static， templates)：代码为：\nfrom flask import Flask,requestfrom flask.templating import render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def test():\tif request.method ==&#x27;GET&#x27;:\t\tprint(&#x27;hello flask&#x27;)\t\treturn render_template(&#x27;test.html&#x27;)\tif request.method == &#x27;POST&#x27;:\t\treturn &#123;&#x27;1&#x27;:&#x27;hahah&#x27;,&#x27;2&#x27;:&#x27;xixixixi&#x27;&#125;if __name__ == &#x27;__main__&#x27;:\tapp.run(debug=&#x27;True&#x27;,host=&#x27;0.0.0.0&#x27;,port=5000)\n\n其中test.html,该文件在templates目录下\n&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;\t&lt;body&gt;\t\t&lt;h1&gt;你好&lt;/h1&gt;\t&lt;/body&gt;&lt;/html&gt;\n\n3.python虚拟环境使用命令行进行安装\npip3 install virtualenv\n\n对于要操作的项目,可以创建一个虚拟环境目录,比如:\nmkdir flaskprojectcd flaskprojectvirtualenv flaskprojectenv\n\n进行激活:\nsource flaskprojectenv/bin/activate\n\n注:退出虚拟环境使用的命令为:deactivate\n3.使用命令启动gunicorn方式一:另开一服务器连接会话，进入到app.py所在目录下,输入命令:\n$ gunicorn app:app\n\n(第一个app指的是app.py的文件名) 注意：一定要在app.py的路径下 这个时候，我们就可以在之前的会话（输入了命令 source flaskprojectenv/bin/activate 的会话 下）输入：\ncurl http://127.0.0.1:8000\n\n检查本地服务器是否运行，可以看到弹出test.html的内容。\n方式二:该方式是为了处理高并发，所以打开多个进程和修改监听端口的方式：\ngunicorn -w 4 -b 127.0.0.1:8000 入口文件名:app\n\n这样我们本地服务器就已经运行起来了，但是远程并不能访问。\n4.下载Nginx\n再开个会话，下载nginx包\n\n$ wget http://nginx.org/download/nginx-1.10.1.tar.gz\n\n\n复制到安装目录·\n\n$ cp nginx-1.10.1.tar.gz /usr/local/\n\n\ncd进入到&#x2F;usr&#x2F;local&#x2F;,进行解压\n\n$ tar -zxvf nginx-1.10.1.tar.gz\n\n\n网上教程直接说这里就可以启动nginx了，但是，&#x2F;usr&#x2F;local下并没有nginx文件夹，只有nginx-1.10.1, 所以要先执行安装步骤为： 进入到nginx-1.10.1目录下，输入命令：\n\n$ ./configure$ make$ make install\n\nmake中可能遇到的问题\n.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using –without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using –withpcre&#x3D; option.解决办法：安装pcre-deve$ yum -y install pcre-devel\n.&#x2F;configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using –without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using –with-zlib&#x3D; option.解决办法：安装zlib-devel $ yum install -y zlib-devel\n下载完后，再输入.&#x2F;configure 再执行make 和make install 即可。安装完成后，最好查看一下是否成功whereis nginx这样我们就知道了nginx所在目录为&#x2F;usr&#x2F;local&#x2F;nginx我们cd进入到nginx目录，再输入 sbin&#x2F;nginx 即可启动nginx\n\n配置nginx对应到项目：先本地测试 curl http://192.168.0.245/ 这里的ip地址是本机的ip地址，然后就会有nginx的html这样就说明了本地是安装成功的。下面进行防火墙和端口的设置，cd进入到&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;，输入命令：vi nginx.conf找到server，修改为：\nserver &#123;\tlisten 80;\tserver_name 139.9.250.150; #对应到自己服务器的公网ip或者域名\t#charset koi8-r;\t#access_log logs/host.access.log main;\troot /tmp/flask_test; #自己项目所在位置\tlocation / &#123;\t\t#gunicorn和nginx交互的端口\t\tproxy_pass http://127.0.0.1:8000;\t\t# 请求转发到多个gunicorn服务器\t\t# proxy_pass http://flask;\t\t# 设置请求头，并将头信息传递给服务器端\t\tproxy_set_header Host $host;\t\t# 设置请求头，传递原始请求ip给 gunicorn 服务器\t\tproxy_set_header X-Real-IP $remote_addr;\t\t&#125;\n修改之后，重新启动nginx，即可在Windows下通过外网访问到该网页。重启命令为：在nginx目录下sbin/nginx -s reload\nmysql8.0的安装\n安装：sudo rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpmsudo yum --enablerepo=mysql80-community install mysql-community-server\n启动mysql服务sudo service mysqld start\n查看root初始的密码, mysql8.0必须要你修改之后才能进行数据库操作cat /var/log/mysqld.log |grep &#x27;temporary password&#x27;\n复制初始默认密码, 进入mysql数据库 mysql -uroot -p\n修改密码:要求大小写,数字,符号ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY &#x27;Wjxxyxb123,&#x27;;\n然后就可以导入.sql文件存储数据库,步骤为:进入数据库create database db1;use db1;source .sql文件位置\n\n","categories":["教程"],"tags":["教程"]},{"title":"MySQL基础教程","url":"/2021/08/19/MySQL%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","content":"数据库和SQL概述数据库的好处\n实现数据持久化\n使用完整的管理系统统一管理，便于查询\n\n数据库相关概念\nDB数据库（database），存储数据的仓库，保存了一系列有组织的数据。\nDBMS数据库管理系统（Database Management System）。数据库是通过 DBMS 创建和操作的容器\n\n​       常见的数据库管理系统：MySql、Oracle、DB2、SqlServer\n\nSQL\n结构化查询语言（Structure Query Language），专门用来 与数据库通信 的语言。\nSQL的优点\n\n\n是一门通用的语言，几乎所有DBMS都支持SQL。\n简单易学。\n灵活使用，可进行非常复杂而又高级的数据库操作。\n\n\n\n数据库存储数据的特点\n将数据放到表中，表再放到库中\n一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。\n表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。\n表由列组，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”。\n表中的数据是按行存储的，每一行类似于java中的“对象”。\n\nMySQL软件的介绍和使用介绍\nMySQL数据库隶属于MySQLAB公司，总部位于瑞典，后被oracle收购。\n优点：①成本低：开放源代码，一般可以免费试用；②简单：很容易安装和使用；③性能高：执行很快。\n\n安装\nDBMS分为两类：①基于共享文件系统的DBMS （Access）；②基于客户机——服务器的DBMS（MySQL、Oracle、SqlServer）。\n版本可分为：社区版（免费），企业版（收费）。\nWindows平台下下载：http://dev.mysql.com/downloads/mysql\n完整安装卸载步骤：https://blog.csdn.net/Y_BlueBlack/article/details/81433401\n\n启动和停止MySQL服务\n方式一：右击此电脑—管理—服务—启动或停止MySQL服务\n方式二：启动：net start mysql服务名停止：net stop mysql服务名\n\nMySQL服务端的登录和退出\n登录\nmysql–h 主机名–u用户名–p密码例：mysql -h localhost -u root -proot\n\n退出quit\n\nMySQL常见命令介绍进入mysql, 在命令行中输入\nmysql–uroot–p####  (其中：####表示密码）例：mysql -uroot -proot查看mysql中有哪些个数据库show databases;新建一个数据库create database 数据库名;例：create database book;选择一个数据库use 数据库名称;例：use test;查询数据表show tables;查看指定的数据库中有哪些数据表show tables from 数据库名;例：show tables from mysql;查询当前所在数据库select database();新建一个数据表create table math(id int,name varchar(20));查看表的结构desc 表名;例：desc math;查看表中的所有记录select * from 表名;例： select * from math;向表中插入记录insert into 表名(列名列表) values(列对应的值的列表);注意：插入varchar或date 型的数据要用单引号引起来例：insert into math (id,name) values(1,&quot;ton&quot;);修改记录update 表名set 列1 = 列1的值, 列2 = 列2的值where ..例：update math set name=&quot;wugang&quot; where id=1;删除记录delete from 表名 where ...例：delete from math where id=1;删除数据表drop table 表名;例：drop table math;\n\n查看MySQL服务端版本\n登录到mysql服务端select version();\n没有登录到mysql服务端mysql --version\n\nMySQL的语法规范\n不区分大小写,但建议关键字大写，表名、列名小写\n每句话用  ;  或  \\g 结尾，最好用分号结尾\n每条命令根据需要，可以进行缩进或换行\n注释：\n单行注释：#注释文字\n单行注释：-- 注释文字\n多行注释：/* 注释文字 */\n\n\n\nDQL语言Data Query Language，数据查询语言\n基础查询\n语法：select 查询列表 from 表明;\n特点\n查询列表可以是：表中的字段、常量值、表达式、函数\n查询的结果可以是一个虚拟表格\n\n\n举例USE myemployees;#1.查询表中的单个字段SELECT last_name FROM employees;#2.查询表中多个字段SELECT last_name,salary,email FROM employees;#3.查询表中的所有字段SELECT * FROM employees;#4.查询常量# select 常量值;# 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要SELECT 100;SELECT &#x27;join&#x27;;#5.查询函数#select 函数名(实参列表);SELECT VERSION();#6.查询表达式 SELECT 100%98;#7.起别名/*1.便于理解2.如果要查询的字段有重名的情况,使用别名区分*/#方式一:使用ASSELECT 100%98 AS 结果;SELECT last_name AS 姓,first_name AS 名 FROM employees;#方式二:使用空格SELECT last_name 姓,first_name 名 FROM employees;#案例:查询salary,结果显示 out putSELECT salary AS &quot;out put&quot; FROM employees;#8.去重# select distinct 字段名 from 表名;#案例:查询员工表中涉及的所有部门编号SELECT DISTINCT department_id FROM employees;#9.+号的作用#案例:查询员工的名和姓,并显示为姓名/*java中的+号:1.运算符:两个操作数都为数据型2.连接符:只要有一个操作数为字符串mysql中的+号:只能作为运算符select 100+90; 两个操作数都为数值型,做加法运算select &#x27;123+90&#x27;;其中一方为字符型,试图将字符型数值转换为数值型\t\t如果转换成功,则继续做加法运算select &#x27;john&#x27;+90; 如果转换失败,则将字符型数值转换成0select null+0; 只要其中一方为null,则结果肯定为null.*/SELECT last_name+first_name AS 姓名 FROM employees; #10.【补充】concat函数 /*功能：拼接字符select concat(字符1，字符2，字符3,...);*/SELECT CONCAT(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) AS 结果 FROM employees;SELECT CONCAT(last_name,first_name) AS 姓名 FROM employees;#11.【补充】ifnull函数#功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值SELECT IFNULL(commission_pct,0) FROM employees;#12.【补充】isnull函数#功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0\n\n条件查询\n语法：select 查询列表 from 表名 where 筛选条件;\n\n分类\n一、按条件表达式筛选\t条件运算符:&gt; &lt; = != &lt;&gt; &gt;= &lt;= &lt;=&gt;安全等于二、按逻辑表达式筛选\t逻辑运算符:&amp;&amp; || |\tand or not\t\t&amp;&amp; 和 and:两个条件都为true，结果为true，反之为false\t|| 和 or:只要有一个条件为true，结果为true，反之为false\t! 或 not:如果连接的条件本身为false，结果为true，反之为false\t\t三、模糊查询\tlike:一般搭配通配符使用，可以判断字符型或数值型\t通配符：%任意多个字符，_任意单个字符\tlike、between and、in、is null\n\n举例\n\n\n#一.按条件表达式筛选#案例1:查询工资&gt;12000的员工信息SELECT * FROM employees WHERE salary&gt;12000;#案例2:查询部门编号不等于90号的员工名和部门编号SELECT last_name,department_id FROM employees WHERE department_id &lt;&gt; 90;#二、按逻辑表达式筛选#案例1:查询工资z在10000到20000之间的员工名、工资及奖金SELECT last_name,salary,commission_pct FROM employees WHERE salary&gt;=10000 AND salary&lt;=20000;#案例2:查询部门编号不是在90-110之间,或者工资高于15000的员工信息SELECT * FROM employees WHERE department_id &lt;90 OR department_id&gt;110 OR salary&gt;15000;#三、模糊查询#1.like#案例1:查询员工名中包含字符a的员工信息SELECT * FROM employees WHERE last_name LIKE &#x27;%a%&#x27;;#案例2:查询员工名中第三个字符为b，第五个字符为a的员工名和工资SELECT last_name,salary FROM employees WHERE last_name LIKE &#x27;__b_a%&#x27;;#案例3:查询员工名种第二个字符为_的员工名SELECT last_name FROM employees WHERE last_name LIKE &#x27;_\\_%&#x27;;#2.between and#案例1:查询员工编号在100到120之间的员工信息SELECT * FROM employees WHERE employee_id&gt;=100 AND employee_id&lt;=120;SELECT * FROM employees WHERE employee_id BETWEEN 100 AND 120;/*注意事项：1.提高语句简洁度2.包含临界值3.两个临界值不能调换顺序*/#3.in/*含义:判断某字段的值是否属于in列表中的某一项特点: 1.使用in提高语句简洁度 2.in列表的值类型必须一致或兼容*/#案例1:查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号SELECT last_name,job_id FROM employees WHERE job_id=&#x27;IT_PROG&#x27; OR job_id=&#x27;AD_PRES&#x27; OR job_id=&#x27;AD_VP&#x27;;SELECT last_name,job_id FROM employees WHERE job_id IN(&#x27;IT_PROG&#x27;,&#x27;AD_PRES&#x27;,&#x27;AD_VP&#x27;);#4.is null/*=或&lt;&gt;不能用于判断null值is null 或 is not null 可以判断null值*/#案例1:查询没有奖金的员工名和奖金率SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NULL;SELECT last_name,commission_pct FROM employees WHERE commission_pct IS NOT NULL;#安全等于&lt;=&gt;#案例1:查询没有奖金的员工名和奖金率SELECT last_name,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;#案例2:查询工资为12000的员工信息SELECT last_name,commission_pct FROM employees WHERE salary &lt;=&gt; 12000;#is null PK &lt;=&gt;#\t      普通类型的数值\tnull值\t\t可读性# is null\t×\t\t  √\t\t  √# &lt;=&gt;\t\t√\t\t  √\t\t  ×\n\n\n\n排序查询\n语法：select 查询列表 from 表 【where 筛选条件】order by 字段名 asc|desc\n\n特点\n\nasc代表是升序，desc代表降序，不写默认升序\norder by 子句可以支持单个字段，多个字段，表达式、函数、别名\norder by 子句一般放在查询语句的最后面，limit子句除外\n\n\n举例\n\n\n#案例1:查询员工信息,要求工资从高到低排序SELECT * FROM employees ORDER BY salary DESC;SELECT * FROM employees ORDER BY salary;#案例2:查询部门编号是&gt;=90，按入职时间的先后进行排序SELECT * FROM employees WHERE department_id&gt;=90 ORDER BY hiredate ASC;#案例3:按年薪的高低显示员工的信息和年薪【按表达式排序】SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC; #案例4:按年薪的高低显示员工的信息和年薪【按别名排序】SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0)) 年薪 DESC;#案例5:按姓名的长度显示员工的姓名和工资【按函数排序】SELECT LENGTH(last_name) 字节长度,last_name,salaryFROM employeesORDER BY LENGTH(last_name) DESC;#案例6:查询员工共信息,要求按工资排序，再按员工编号排序【按多个字段排序】SELECT * FROM employeesORDER BY salary ASC,employee_id DESC;\n\n\n\n常见函数\n概念将一组逻辑语句封装在方法中，对外暴露方法名。SQL 提供给了我们内置函数，同时，我们也可以自定义函数。\n\n优点\n\n隐藏实现细节\n提高代码复用性\n\n\n语法：select 函数名(实参列表) 【from 表】;\n\n分类\n\n单行函数\n分组函数，做统计使用\n\n\n\n单行函数\n常见的单行函数：字符函数、数学函数、日期函数、其他函数、流程控制函数\n\n字符函数举例#一.字符函数#1.length 获取参数值的字节值SELECT LENGTH(&#x27;subei&#x27;);SELECT LENGTH(&#x27;鬼谷子qwe&#x27;);SHOW VARIABLES LIKE &#x27;%char%&#x27;;#2.concat 拼接字符串SELECT CONCAT(last_name,&#x27;_&#x27;,first_name) 姓名 FROM employees;#3.upper:变大写、lower：变小写SELECT UPPER(&#x27;ton&#x27;);SELECT LOWER(&#x27;ton&#x27;);#示例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;#4.substr、substring#注意:索引从1开始#截取从指定所有处后面的所以字符SELECT SUBSTR(&#x27;吴刚伐桂在天上&#x27;,4) out_put;#截取从指定索引处指定字符长度的字符SELECT SUBSTR(&#x27;吴刚伐桂在天上&#x27;,1,2) out_put;#案例:姓名中首字符大写,其他字符小写，然后用_拼接,显示出来SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#x27;_&#x27;,LOWER(SUBSTR(last_name,2))) out_put FROM employees;#5.instr:获取子串第一次出现的索引,找不到返回0SELECT INSTR(&#x27;MySQL技术进阶&#x27;,&#x27;技术&#x27;) AS out_put;#6.trim:去前后空格SELECT LENGTH(TRIM(&#x27;\t霍山\t&#x27;)) AS out_put;SELECT TRIM(&#x27;+&#x27; FROM &#x27;++++李刚+++刘邦+++&#x27;) AS out_put;#7.lpad:用指定的字符实现左填充指定长度SELECT LPAD(&#x27;梅林&#x27;,8,&#x27;+&#x27;) AS out_put;#8.rpad:用指定的字符实现右填充指定长度SELECT RPAD(&#x27;梅林&#x27;,5,&#x27;&amp;&#x27;) AS out_put;#9.replace:替换SELECT REPLACE(&#x27;莉莉伊万斯的青梅竹马是詹姆&#x27;,&#x27;詹姆&#x27;,&#x27;斯内普&#x27;) AS out_put;\n\n\n\n数学函数举例#1.round:四舍五入SELECT ROUND(1.45);SELECT ROUND(1.567,2);#2.ceil:向上取整,返回&gt;=该参数的最小整数SELECT CEIL(1.005);SELECT CEIL(-1.002);#3.floor:向下取整,返回&lt;=该参数的最大整数SELECT FLOOR(-9.99);#4.truncate:截断SELECT TRUNCATE(1.65,1);#5.mod:取余SELECT MOD(10,3);#6.rand:获取随机数，返回0-1之间的小数SELECT RAND();\n\n日期函数举例#1.now:返回当前系统时间+日期SELECT NOW();#2.year:返回年SELECT YEAR(NOW());SELECT YEAR(hiredate) 年 FROM employees;#3.month:返回月#MONTHNAME:以英文形式返回月SELECT MONTH(NOW());SELECT MONTHNAME(NOW());#4.day:返回日#DATEDIFF:返回两个日期相差的天数SELECT DAY(NOW());SELECT DATEDIFF(&#x27;2020/06/30&#x27;,&#x27;2020/06/21&#x27;);#5.str_to_date:将字符通过指定格式转换成日期SELECT STR_TO_DATE(&#x27;2020-5-13&#x27;,&#x27;%Y-%c-%d&#x27;) AS out_put;#6.date_format:将日期转换成字符SELECT DATE_FORMAT(&#x27;2020/6/6&#x27;,&#x27;%Y年%m月%d日&#x27;) AS out_put;SELECT DATE_FORMAT(NOW(),&#x27;%Y年%m月%d日&#x27;) AS out_put;#7.curdate:返回当前日期SELECT CURDATE();#8.curtime:返回当前时间SELECT CURTIME();\n\n流程函数#1.if函数: if else效果SELECT IF(10&lt;5,&#x27;大&#x27;,&#x27;小&#x27;);SELECT last_name,commission_pct,IF(commission_pct IS NULL,&#x27;没奖金！！！&#x27;,&#x27;有奖金!!!&#x27;) 备注 FROM employees;#2.case函数#使用一:switch case 的效果/*java中switch(变量或表达式)&#123;\tcase 常量1:语句1;break;\t...\tdefault:语句n;break;&#125;mysql中case 要判断的变量或表达式when 常量1 then 要显示的值1或语句1when 常量2 then 要显示的值2或语句2...else 要显示的值n或语句nend#案例:查询员工的工资,要求:部门号=30,显示的工资为1.1倍部门号=40,显示的工资为1.2倍部门号=50,显示的工资为1.3倍其他部门,显示的工资为原工资*/SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees;#3.case函数的使用二:类似于多重if/*java中:if(条件1)&#123;\t语句1;&#125;else if(条件2)&#123;\t语句2;&#125;...else&#123;\t语句n;&#125;\tmysql中:case when 条件1 then 要显示的值1或语句1when 条件2 then 要显示的值2或语句2...else 要显示的值n或语句nend*/#案例:查询员工的工资的情况/*如果工资&gt;20000，显示A级别如果工资&gt;15000，显示B级别如果工资&gt;10000，显示c级别否则，显示D级别*/SELECT salary,CASEWHEN salary&gt;20000 THEN &#x27;A&#x27;WHEN salary&gt;15000 THEN &#x27;B&#x27;WHEN salary&gt;10000 THEN &#x27;C&#x27;ELSE &#x27;D&#x27;END AS 工资等级FROM employees;\n\n其他函数举例#version 当前数据库服务器的版本SELECT VERSION();#database 当前打开的数据库SELECT DATABASE();#user当前用户SELECT USER();#password(&#x27;字符&#x27;)：返回该字符的密码形式SELECT PASSWORD(&#x27;a&#x27;);#md5(&#x27;字符&#x27;):返回该字符的md5加密形式SELECT MD5(&#x27;a&#x27;);\n\n\n\n分组函数\n用作统计使用，又称为聚合函数、统计函数或组函数\n\n特点\n\nsum和avg一般用于处理数值型max、min、count可以处理任何数据类型\n以上分组函数都忽略null\n都可以搭配distinct使用，实现去重的统计\ncount(字段)：统计该字段非空值的个数\ncount(*):统计结果集的行数\n和分组函数一同查询的字段，要求是group by后出现的字段\n\n\n举例\n\n\n#1.简单使用SELECT SUM(salary) FROM employees;SELECT AVG(salary) FROM employees;SELECT MAX(salary) FROM employees;SELECT MIN(salary) FROM employees;SELECT COUNT(salary) FROM employees;SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数FROM employees;#2.参数支持哪些数据类型SELECT SUM(last_name),AVG(last_name) FROM employees;SELECT SUM(hiredate),AVG(hiredate) FROM employees;SELECT MAX(last_name),MIN(last_name) FROM employees;SELECT MAX(hiredate),MIN(hiredate) FROM employees;SELECT COUNT(commission_pct) FROM employees;SELECT COUNT(last_name) FROM employees;#3.是否忽略nullSELECT SUM(commission_pct),AVG(commission_pct) FROM employees;SELECT commission_pct FROM employees;SELECT SUM(commission_pct),AVG(commission_pct),SUM(commission_pct)/35,AVG(commission_pct)/107 FROM employees;SELECT MAX(commission_pct),MIN(commission_pct) FROM employees;SELECT COUNT(commission_pct) FROM employees;#4.和distinct搭配SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;#5.count函数详解SELECT COUNT(salary) FROM employees;SELECT COUNT(*) FROM employees;SELECT COUNT(1) FROM employees;/*效率上：MyISAM存储引擎，count(*)最高InnoDB存储引擎，count(*)和count(1)效率&gt;count(字段)*/#6.和分组函数一同查询的字段有限制SELECT AVG(salary),employee_id FROM employees;\n\n\n\n分组查询\n语法\n\nselect 分组函数,分组后的字段from 表【where 筛选条件】group by 分组的字段【having 分组后的筛选】【order by 排序列表】\n\n注意：查询列表必须特殊,要求是分组函数和group by后出现的字段\n\n特点\n\n分组查询的筛选    \t\t\t使用关键字\t筛选的表\t位置分组前筛选\twhere\t\t原始表\t\tgroup by的前面分组后筛选\thaving\t\t分组后的结果\tgroup by的后面1.分组函数做条件肯定是放在having子句中2.能用分组前筛选的，就优先考虑使用分组前筛选\ngroup by子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求),表达式或函数(使用较少)\n也可以添加排序(排序放在整个分组查询的最后)\n\n\n举例\n\n\n#引入:查询每个部门的平均工资SELECT AVG(salary) FROM employees;#案例1:查询每个工种的最高工资SELECT MAX(salary),job_id FROM employees GROUP BY job_id;#案例2:查询每个位置上的部门个数SELECT COUNT(*),location_idFROM departmentsGROUP BY location_id;#添加筛选条件#案例1:查询邮箱中包含a字符的，每个部门的平均工资SELECT AVG(salary),department_id FROM employeesWHERE email LIKE &#x27;%a%&#x27; GROUP BY department_id;#案例2:查询有奖金的每个领导手下员工的最高工资SELECT MAX(salary),manager_id FROM employeesWHERE commission_pct IS NOT NULLGROUP BY manager_id;#添加复杂的筛选条件#案例1:查询哪个部门的员工个数&gt;2#1.查询每个部门的员工个数SELECT COUNT(*),department_id FROM employeesGROUP BY department_id;#2.根据1的结果进行筛选，查询哪个部门的员工个数大于2SELECT COUNT(*),department_id FROM employeesGROUP BY department_id HAVING COUNT(*)&gt;2;#案例2:查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资 #1.查询每个工种有奖金的员工的最高工资 SELECT MAX(salary),job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id; #2.根据结果继续筛选，最高工资&gt;12000 SELECT MAX(salary), job_id FROM employees WHERE commission_pct IS NOT NULL GROUP BY job_id HAVING MAX(salary)&gt;12000; #按表达式或函数分组#案例:按员工姓名的长度分组,查询每一组的员工个数,筛选员工个数&gt;5#1.查询每个长度的员工个数 SELECT COUNT(*),LENGTH(last_name) len_name FROM employees GROUP BY LENGTH(last_name); #2.添加筛选条件SELECT COUNT(*) c,LENGTH(last_name) len_name FROM employees GROUP BY len_name HAVING c&gt;5;#按多个字段查询#案例:查询每个部门每个工种的员工的平均工资SELECT AVG(salary),department_id,job_idFROM employees GROUP BY department_id,job_id;#添加排序#案例:查询每个部门每个工种的员工的平均工资,按平均工资的高低查询SELECT AVG(salary),department_id,job_idFROM employees GROUP BY department_id,job_idORDER BY AVG(salary) DESC;\n\n\n\n连接查询\n含义:又称多表查询,当查询的数据来自多个表时,就会用到连接查询\n笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行\n如何避免:添加有效的连接条件\n分类\n\n按年代分类：\tsql92标准:仅仅支持内连接\tsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\t按功能分类：\t内连接：\t等值连接\t非等值连接\t自连接外连接：\t左外连接\t右外连接\t全外连接\t\t交叉连接\n\n\nsql92标准案例#1、等值连接/*1.多表等值连接的结果为多表的交集部分2.n表连接，至少需要n-1个连接条件3.多表的顺序没有要求4.一般需要为表起别名5.可以搭配前面介绍的所有子句使用，比如排序、分组、筛选*/#案例1：查询女神名和对应的男神名SELECT NAME,boyName FROM boys,beautyWHERE beauty.boyfriend_id= boys.id;#案例2：查询员工名和对应的部门名SELECT last_name,department_name FROM employees,departmentsWHERE employees.`department_id`=departments.`department_id`;#2、为表起别名/*1.提高语句的简洁度2.区分多个重名的字段注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定*/#查询员工名、工种号、工种名SELECT e.last_name,e.job_id,j.job_titleFROM employees  e,jobs jWHERE e.`job_id`=j.`job_id`;#3、两个表的顺序是否可以调换#查询员工名、工种号、工种名SELECT e.last_name,e.job_id,j.job_titleFROM jobs j,employees eWHERE e.`job_id`=j.`job_id`;#4、可以加筛选#案例：查询有奖金的员工名、部门名SELECT last_name,department_name,commission_pctFROM employees e,departments dWHERE e.`department_id`=d.`department_id`AND e.`commission_pct` IS NOT NULL;#案例2：查询城市名中第二个字符为o的部门名和城市名SELECT department_name,cityFROM departments d,locations lWHERE d.`location_id` = l.`location_id`AND city LIKE &#x27;_o%&#x27;;#5、可以加分组#案例1：查询每个城市的部门个数SELECT COUNT(*) 个数,cityFROM departments d,locations lWHERE d.`location_id`=l.`location_id`GROUP BY city;#案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT department_name,d.`manager_id`,MIN(salary)FROM departments d,employees eWHERE d.`department_id`=e.`department_id`AND commission_pct IS NOT NULLGROUP BY department_name,d.`manager_id`;#6、可以加排序#案例：查询每个工种的工种名和员工的个数，并且按员工个数降序SELECT job_title,COUNT(*)FROM employees e,jobs jWHERE e.`job_id`=j.`job_id`GROUP BY job_titleORDER BY COUNT(*) DESC;#7、可以实现三表连接？#案例：查询员工名、部门名和所在的城市SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE &#x27;s%&#x27;ORDER BY department_name DESC;#2、非等值连接#案例1：查询员工的工资和工资级别SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`AND g.`grade_level`=&#x27;A&#x27;;/*select salary,employee_id from employees;select * from job_grades;CREATE TABLE job_grades(grade_level VARCHAR(3), lowest_sal  int, highest_sal int);INSERT INTO job_gradesVALUES (&#x27;A&#x27;, 1000, 2999);INSERT INTO job_gradesVALUES (&#x27;B&#x27;, 3000, 5999);INSERT INTO job_gradesVALUES(&#x27;C&#x27;, 6000, 9999);INSERT INTO job_gradesVALUES(&#x27;D&#x27;, 10000, 14999);INSERT INTO job_gradesVALUES(&#x27;E&#x27;, 15000, 24999);INSERT INTO job_gradesVALUES(&#x27;F&#x27;, 25000, 40000);*/#3、自连接#案例：查询 员工名和上级的名称SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.`manager_id`=m.`employee_id`;\n\n\nsql99标准案例\n语法\n\nselect 查询列表from 表1 别名 【连接类型】join 表2 别名 on 连接条件【where 筛选条件】【group by 分组】【having 筛选条件】【order by 排序列表】\n\n\n\n分类\n\n内连接（★）：inner外连接\t左外(★):left 【outer】\t右外(★)：right 【outer】\t全外：full【outer】交叉连接：cross \n\n\n举例\n\n#一、内连接/*语法：select 查询列表from 表1 别名inner join 表2 别名on 连接条件;分类：等值非等值自连接特点：①添加排序、分组、筛选②inner可以省略③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读④inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集*/#1、等值连接#案例1.查询员工名、部门名SELECT last_name,department_name FROM departments dINNER JOIN  employees eON e.`department_id` = d.`department_id`;#案例2.查询名字中包含e的员工名和工种名（添加筛选）SELECT last_name,job_title FROM employees eINNER JOIN jobs j ON e.`job_id`=  j.`job_id`WHERE e.`last_name` LIKE &#x27;%e%&#x27;;#案例3.查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）#1.查询每个城市的部门个数#2.在1结果上筛选满足条件的SELECT city,COUNT(*) 部门个数FROM departments dINNER JOIN locations lON d.`location_id`=l.`location_id`GROUP BY cityHAVING COUNT(*)&gt;3;#案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）#1.查询每个部门的员工个数SELECT COUNT(*),department_nameFROM employees eINNER JOIN departments dON e.`department_id`=d.`department_id`GROUP BY department_name;#2.在1结果上筛选员工个数&gt;3的记录，并排序SELECT COUNT(*) 个数,department_nameFROM employees eINNER JOIN departments dON e.`department_id`=d.`department_id`GROUP BY department_nameHAVING COUNT(*)&gt;3ORDER BY COUNT(*) DESC;#案例5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接）SELECT last_name,department_name,job_titleFROM employees eINNER JOIN departments d ON e.`department_id`=d.`department_id`INNER JOIN jobs j ON e.`job_id` = j.`job_id`ORDER BY department_name DESC;#二、非等值连接#查询员工的工资级别SELECT salary,grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`; #查询工资级别的个数&gt;20的个数，并且按工资级别降序SELECT COUNT(*),grade_levelFROM employees eJOIN job_grades gON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`GROUP BY grade_levelHAVING COUNT(*)&gt;20ORDER BY grade_level DESC;#三、自连接 #查询员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eJOIN employees mON e.`manager_id`= m.`employee_id`; #查询姓名中包含字符k的员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eJOIN employees mON e.`manager_id`= m.`employee_id`WHERE e.`last_name` LIKE &#x27;%k%&#x27;;#二、外连接 /*应用场景：用于查询一个表中有，另一个表没有的记录 特点：1、外连接的查询结果为主表中的所有记录\t如果从表中有和它匹配的，则显示匹配的值\t如果从表中没有和它匹配的，则显示null\t外连接查询结果=内连接结果+主表中有而从表没有的记录2、左外连接，left join左边的是主表   右外连接，right join右边的是主表3、左外和右外交换两个表的顺序，可以实现同样的效果 4、全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的*/#引入：查询男朋友 不在男神表的的女神名SELECT * FROM beauty;SELECT * FROM boys; #左外连接SELECT b.*,bo.* FROM boys boLEFT OUTER JOIN beauty bON b.`boyfriend_id` = bo.`id`WHERE b.`id` IS NULL; #案例1：查询哪个部门没有员工#左外SELECT d.*,e.employee_idFROM departments dLEFT OUTER JOIN employees eON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#右外 SELECT d.*,e.employee_idFROM employees eRIGHT OUTER JOIN departments dON d.`department_id` = e.`department_id`WHERE e.`employee_id` IS NULL;#全外USE girls;SELECT b.*,bo.* FROM beauty bFULL OUTER JOIN boys boON b.`boyfriend_id` = bo.id;#交叉连接SELECT b.*,bo.* FROM beauty bCROSS JOIN boys bo;\n\n\n子查询\n含义：出现在其他语句中的select语句，称为子查询或内查询，外部的查询语句称为主查询或外查询。\n分类\n按结果集的行列数不同\n标量子查询(1行1列)\n列子查询(n行1列)\n行子查询(1行n列)\n表子查询(n行m列)\n\n\n按子查询出现的位置\nselect后面：仅支持标量子查询\nfrom后：支持表子查询\nwhere或having后：\n标量子查询\n列子查询\n行子查询\n\n\nexists后面：表子查询\n\n\n\n\n\n举例\n#一、where或having后面/*1、标量子查询（单行子查询）2、列子查询（多行子查询）3、行子查询（多列多行）特点：①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用&gt; &lt; &gt;= &lt;= = &lt;&gt;列子查询，一般搭配着多行操作符使用in、any/some、all④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果*/#1.标量子查询★#案例1：谁的工资比 Abel 高?#①查询Abel的工资SELECT salaryFROM employeesWHERE last_name = &#x27;Abel&#x27;;#②查询员工的信息，满足 salary&gt;①结果SELECT *FROM employeesWHERE salary&gt;(​\tSELECT salary​\tFROM employees​\tWHERE last_name = &#x27;Abel&#x27;​\t);#案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资#①查询141号员工的job_idSELECT job_id FROM employeesWHERE employee_id = 141;#②查询143号员工的salarySELECT salary FROM employeesWHERE employee_id = 143;#③查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②SELECT last_name,job_id,salaryFROM employeesWHERE job_id = (\tSELECT job_id\tFROM employees\tWHERE employee_id = 141) AND salary&gt;(\tSELECT salary\tFROM employees\tWHERE employee_id = 143);#案例3：返回公司工资最少的员工的last_name,job_id和salary#①查询公司的最低工资SELECT MIN(salary) FROM employees;#②查询last_name,job_id和salary，要求salary=①SELECT last_name,job_id,salaryFROM employeesWHERE salary=(\tSELECT MIN(salary)\tFROM employees);#案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资#①查询50号部门的最低工资SELECT  MIN(salary)FROM employeesWHERE department_id = 50;#②查询每个部门的最低工资SELECT MIN(salary),department_idFROM employeesGROUP BY department_id;#③ 在②基础上筛选，满足min(salary)&gt;①SELECT MIN(salary),department_idFROM employeesGROUP BY department_idHAVING MIN(salary)&gt;(\tSELECT  MIN(salary)\tFROM employees\tWHERE department_id = 50);#非法使用标量子查询SELECT MIN(salary),department_idFROM employeesGROUP BY department_idHAVING MIN(salary)&gt;(\tSELECT  salary\tFROM employees\tWHERE department_id = 250);#2.列子查询（多行子查询）★#案例1：返回location_id是1400或1700的部门中的所有员工姓名#①查询location_id是1400或1700的部门编号SELECT DISTINCT department_idFROM departmentsWHERE location_id IN(1400,1700);#②查询员工姓名，要求部门号是①列表中的某一个SELECT last_nameFROM employeesWHERE department_id  &lt;&gt;ALL(\tSELECT DISTINCT department_id\tFROM departments\tWHERE location_id IN(1400,1700));#案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary#①查询job_id为‘IT_PROG’部门任一工资SELECT DISTINCT salary FROM employeesWHERE job_id = &#x27;IT_PROG&#x27;;#②查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ANY(\tSELECT DISTINCT salary\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MAX(salary)\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;#案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salarySELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ALL(\tSELECT DISTINCT salary\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MIN( salary)\tFROM employees\tWHERE job_id = &#x27;IT_PROG&#x27;) AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;#3、行子查询（结果集一行多列或多行多列）#案例：查询员工编号最小并且工资最高的员工信息SELECT * FROM employeesWHERE (employee_id,salary)=(\tSELECT MIN(employee_id),MAX(salary)\tFROM employees);#①查询最小的员工编号SELECT MIN(employee_id) FROM employees;#②查询最高工资SELECT MAX(salary) FROM employees;#③查询员工信息SELECT * FROM employeesWHERE employee_id=(\tSELECT MIN(employee_id)\tFROM employees)AND salary=(\tSELECT MAX(salary)\tFROM employees);#二、select后面/*仅仅支持标量子查询*/#案例：查询每个部门的员工个数SELECT d.*,(\tSELECT COUNT(*)\tFROM employees e\tWHERE e.department_id = d.`department_id` ) 个数 FROM departments d;#案例2：查询员工号=102的部门名SELECT (\tSELECT department_name,e.department_id\tFROM departments d\tINNER JOIN employees e\tON d.department_id=e.department_id\tWHERE e.employee_id=102\t) 部门名;#三、from后面/*将子查询结果充当一张表，要求必须起别名*/#案例：查询每个部门的平均工资的工资等级#①查询每个部门的平均工资SELECT AVG(salary),department_idFROM employees GROUP BY department_id;SELECT * FROM job_grades;#②连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_salSELECT  ag_dep.*,g.`grade_level`FROM (\tSELECT AVG(salary) ag,department_id\tFROM employees\tGROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal;#四、exists后面（相关子查询）/*语法：exists(完整的查询语句)结果：1或0*/SELECT EXISTS(SELECT employee_id FROM employees WHERE salary=300000);#案例1：查询有员工的部门名#inSELECT department_nameFROM departments dWHERE d.`department_id` IN(\tSELECT department_id\tFROM employees);#existsSELECT department_nameFROM departments dWHERE EXISTS(\tSELECT *\tFROM employees e\tWHERE d.`department_id`=e.`department_id`);#案例2：查询没有女朋友的男神信息#inSELECT bo.*FROM boys boWHERE bo.id NOT IN(\tSELECT boyfriend_id\tFROM beauty);#existsSELECT bo.*FROM boys boWHERE NOT EXISTS(\tSELECT boyfriend_id\tFROM beauty b\tWHERE bo.`id`=b.`boyfriend_id`);\n\n\n\n分页查询\n含义：显示指定起始索引，行数的查询结果\n语法：\n\n\tselect 查询列表\tfrom 表\t【join type join 表2\ton 连接条件\twhere 筛选条件\tgroup by 分组字段\thaving 分组后的筛选\torder by 排序的字段】\tlimit 【offset,】size;注意\toffset要显示条目的起始索引（起始索引从0开始）\tsize 要显示的条目个数\n\n\n特点\n\n①limit语句放在查询语句的最后②公式\t要显示的页数 page，每页的条目数size\tselect 查询列表 from 表limit (page-1)*size,size;\tsize=10page  1\t02  \t103\t20\n\n\n举例\n\n#案例1：查询前五条员工信息SELECT * FROM  employees LIMIT 0,5;SELECT * FROM  employees LIMIT 5;#案例2：查询第11条——第25条SELECT * FROM employees LIMIT 10,15;#案例3：有奖金的员工信息，并且工资较高的前10名显示出来SELECT * FROM employees WHERE commission_pct IS NOT NULL ORDER BY salary DESC LIMIT 10 ;\n\n联合查询\n含义：union (联合、合并)，将多条查询语句的结果合并成一个结果\n语法\n\n查询语句1union 【all】查询语句2union 【all】...\n\n\n特点\n\n要求多条查询语句的查询列数是一致的！\n要求多条查询语句的查询的每一列的类型和顺序最好一致\nunion关键字默认去重，如果使用union all 可以包含重复项\n列名默认为第一个表的选取列名\n\n\n案例\n\n\n#引入的案例：查询部门编号&gt;90或邮箱包含a的员工信息SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;SELECT * FROM employees  WHERE email LIKE &#x27;%a%&#x27;UNIONSELECT * FROM employees  WHERE department_id&gt;90;#案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息SELECT id,cname,csex FROM t_ca WHERE csex=&#x27;男&#x27;UNIONSELECT t_id,tName,tGender FROM t_ua WHERE tGender=&#x27;male&#x27;;\n\n\n\nDML语言Data Manipulation Language，数据操作语言\n\n插入：insert\n修改：update\n删除：delete\n\n插入方式\n方式一：\n语法：insert into 表名(字段名) values(值);\n特点\n要求值得类型和字段的类型要一致或兼容;\n字段的个数和顺序不一定与原始表中的字段个数和顺序一致但必须保证值和字段一一对应；\n假如表中有可以为null的字段，注意可以通过以下两种方式插入null值\n字段和值都省略\n字段写上但值为nul\n\n\n字段和值的个数必须一致\n字段名可以省略，默认所有列\n\n\n\n\n\n举例\nSELECT * FROM beauty;#1.插入的值的类型要与列的类型一致或兼容INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,&#x27;唐艺昕&#x27;,&#x27;女&#x27;,&#x27;1990-4-23&#x27;,&#x27;1898888888&#x27;,NULL,2);#2.不可以为null的列必须插入值。可以为null的列如何插入值？    #方法一：    INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)    VALUES(13,&#x27;唐艺昕&#x27;,&#x27;女&#x27;,&#x27;1990-4-23&#x27;,&#x27;1898888888&#x27;,NULL,2);    #方法二：    INSERT INTO beauty(id,NAME,sex,phone)    VALUES(15,&#x27;娜扎&#x27;,&#x27;女&#x27;,&#x27;1388888888&#x27;);#3.列的顺序是否可以调换INSERT INTO beauty(NAME,sex,id,phone)VALUES(&#x27;蒋欣&#x27;,&#x27;女&#x27;,16,&#x27;110&#x27;);#4.列数和值的个数必须一致INSERT INTO beauty(NAME,sex,id,phone)VALUES(&#x27;关晓彤&#x27;,&#x27;女&#x27;,17,&#x27;110&#x27;);#5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致INSERT INTO beautyVALUES(18,&#x27;张飞&#x27;,&#x27;男&#x27;,NULL,&#x27;119&#x27;,NULL,NULL);\n\n\n方式二\n\n语法：insert into 表名 set 列名&#x3D;值······\n\n\n两种方式区别\n\n\n1.方式一支持一次插入多行，语法如下：insert into 表名【(字段名,..)】 values(值，..),(值，...),...;2.方式一支持子查询，语法如下：    insert into 表名 查询语句;    #1、方式一支持插入多行,方式二不支持INSERT INTO beautyVALUES(23,&#x27;唐艺昕1&#x27;,&#x27;女&#x27;,&#x27;1990-4-23&#x27;,&#x27;1898888888&#x27;,NULL,2),(24,&#x27;唐艺昕2&#x27;,&#x27;女&#x27;,&#x27;1990-4-23&#x27;,&#x27;1898888888&#x27;,NULL,2),(25,&#x27;唐艺昕3&#x27;,&#x27;女&#x27;,&#x27;1990-4-23&#x27;,&#x27;1898888888&#x27;,NULL,2);#2、方式一支持子查询，方式二不支持INSERT INTO beauty(id,NAME,phone) SELECT 26,&#x27;宋茜&#x27;,&#x27;11809866&#x27;;INSERT INTO beauty(id,NAME,phone) SELECT id,boyname,&#x27;1234567&#x27; FROM boys WHERE id&lt;3;       \n\n修改语句\n语法：update 表名 set 列&#x3D;新值,列&#x3D;新值,… where 筛选条件;\n\n举例\n#1.修改单表的记录#案例1：修改beauty表中姓唐的女神的电话为13899888899UPDATE beauty SET phone = &#x27;13899888899&#x27;WHERE NAME LIKE &#x27;唐%&#x27;;#案例2：修改boys表中id好为2的名称为张飞，魅力值 10UPDATE boys SET boyname=&#x27;张飞&#x27;,usercp=10WHERE id=2;\n\n\n修改多表记录(补充)\n\n\n先连接多表，再进行修改\n\n举例\n#2.修改多表的记录#案例 1：修改张无忌的女朋友的手机号为114UPDATE boys boINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`phone`=&#x27;119&#x27;,bo.`userCP`=1000WHERE bo.`boyName`=&#x27;张无忌&#x27;;#案例2：修改没有男朋友的女神的男朋友编号都为2号UPDATE boys boRIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`boyfriend_id`=2 WHERE bo.`id` IS NULL;\n\n删除语句\n方式一：delete\n语法\n\n1、单表的删除【★】delete from 表名 where 筛选条件2、多表的删除【补充】sql92语法：delete 表1的别名,表2的别名from 表1 别名,表2 别名where 连接条件and 筛选条件;sql99语法：delete 表1的别名,表2的别名from 表1 别名inner|left|right join 表2 别名 on 连接条件where 筛选条件;\n\n\n方式二\n语法\n\n语法：truncate table 表名;#案例：将魅力值&gt;100的男神信息删除TRUNCATE TABLE boys ;\n\n\n两种方式区别\n\n1.delete 可以加where 条件，truncate不能加2.truncate删除，效率高一点3.假如要删除的表中有自增长列，  如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。4.truncate删除没有返回值，delete删除有返回值5.truncate删除不能回滚，delete删除可以回滚.\n\nDDL语言Data Definition Language 数据定义语言\n库的管理\n创建库\n\ncreate database 【if not exists】 库名【 character set 字符集名】;#案例：创建库Books  CREATE DATABASE IF NOT EXISTS books ;\n\n\n修改库\n\nalter database 库名 character set 字符集名;#案例：更改库的字符集ALTER DATABASE books CHARACTER SET gbk;\n\n\n删除库drop database 【if exists】 库名;#案例：库的删除DROP DATABASE IF EXISTS books;\n\n表的管理\n表的创建\n\n/*语法：create table 表名(\t列名 列的类型【(长度) 约束】,\t列名 列的类型【(长度) 约束】,\t列名 列的类型【(长度) 约束】,\t...\t列名 列的类型【(长度) 约束】)*/#案例：创建表BookCREATE TABLE book (  id INT,  #编号  bName VARCHAR (20),  #图书名  price DOUBLE,  #价格  authorId INT,  #作者编号  publishDate DATETIME#出版日期) ;DESC book;#案例：创建表authorCREATE TABLE IF NOT EXISTS author (  id INT,  au_n`author`ame VARCHAR (20),  nation VARCHAR (10));DESC author ;\n\n\n表的修改\n\n1.添加列alter table 表名 add column 列名 类型 【first|after 字段名】;2.修改列的类型或约束alter table 表名 modify column 列名 新类型 【新约束】;3.修改列名alter table 表名 change column 旧列名 新列名 类型;4 .删除列alter table 表名 drop column 列名;5.修改表名alter table 表名 rename 【to】 新表名;案例：#①修改列名ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME ;#②修改列的类型或约束ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;#③添加新列ALTER TABLE author ADD COLUMN annual DOUBLE; #④删除列ALTER TABLE book_author DROP COLUMN  annual;#⑤修改表名ALTER TABLE book_author RENAME TO author;DESC book;\n\n\n表的删除\n\ndrop table【if exists】 表名;案例：DROP TABLE IF EXISTS book_author;SHOW TABLES;#通用的写法：DROP DATABASE IF EXISTS 旧库名;CREATE DATABASE 新库名 ;DROP TABLE IF EXISTS 旧表名;CREATE TABLE  表名();\n\n\n表的复制\n\n1、复制表的结构create table 表名 like 旧表;2、复制表的结构+数据create table 表名 select 查询列表 from 旧表【where 筛选】;案例INSERT INTO author VALUES(1,&#x27;村上春树&#x27;,&#x27;日本&#x27;),(2,&#x27;莫言&#x27;,&#x27;中国&#x27;),(3,&#x27;冯唐&#x27;,&#x27;中国&#x27;),(4,&#x27;金庸&#x27;,&#x27;中国&#x27;);SELECT * FROM Author;SELECT * FROM copy2;#1.仅仅复制表的结构CREATE TABLE copy LIKE author;#2.复制表的结构+数据CREATE TABLE copy2 SELECT * FROM author;#只复制部分数据CREATE TABLE copy3 SELECT id,au_nameFROM author WHERE nation=&#x27;中国&#x27;;#仅仅复制某些字段CREATE TABLE copy4 SELECT id,au_nameFROM author WHERE 0;\n\n数据类型数值型\n整形\n\n\n字节tinyint、smallint、mediumint、int&#x2F;integer、bigint1\t                 2\t\t   3\t            4\t\t 8\n\n\n特点\n\n如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字\n如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值\n如果不设置长度，会有默认的长度注意：长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用\n\n\n举例\n\n\n#1.如何设置无符号和有符号DROP TABLE IF EXISTS tab_int ;CREATE TABLE tab_int (t1 INT (7) ZEROFILL, t2 INT (7) ZEROFILL) ;DESC tab_int ;INSERT INTO tab_int VALUES (- 123456) ;INSERT INTO tab_int VALUES (- 123456, - 123456) ;INSERT INTO tab_int VALUES (2147483648, 4294967296) ;INSERT INTO tab_int VALUES (123, 123) ;SELECT * FROM tab_int ;\n\n\n浮点型\n\n定点数：dec(M,D)；decimal(M,D)\n浮点数：float(M,D) 4；double(M,D) 8\n特点\nM代表整数部位+小数部位的个数，D代表小数部位\n如果超出范围，则报out or range异常，并且插入临界值\nM和D都可以省略，但对于定点数，M默认为10，D默认为0\n如果精度要求较高，则优先考虑使用定点数\n\n\n\n\n举例\n\n\n#测试M和DDROP TABLE tab_float ;CREATE TABLE tab_float (f1 FLOAT, f2 DOUBLE, f3 DECIMAL) ;SELECT * FROM tab_float ;DESC tab_float ;INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);INSERT INTO tab_float VALUES(123.456,123.456,123.456);INSERT INTO tab_float VALUES(123.4,123.4,123.4);INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);#原则：#所选择的类型越简单越好，能保存数值的类型越小越好\n\n字符型\n较短的文本：char、varchar\n\n较长的文本：text、blob(较大的二进制)\n\n特点\n写法\t\t\tM的意思\t                    特点           空间的耗费\t效率char\t\t最大的字符数，可以省略，默认为1\t 固定长度的字符\t   比较耗费\t 高char(M)varchar         最大的字符数，不可以省略\t         可变长度的字符\t   比较节省       低varchar(M)\n\n举例\n\n\nCREATE TABLE tab_char(c1 ENUM(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;));INSERT INTO tab_char VALUES(&#x27;a&#x27;);INSERT INTO tab_char VALUES(&#x27;b&#x27;);INSERT INTO tab_char VALUES(&#x27;c&#x27;);INSERT INTO tab_char VALUES(&#x27;m&#x27;);INSERT INTO tab_char VALUES(&#x27;A&#x27;);SELECT * FROM tab_set;CREATE TABLE tab_set(s1 SET(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;));INSERT INTO tab_set VALUES(&#x27;a&#x27;);INSERT INTO tab_set VALUES(&#x27;A,B&#x27;);INSERT INTO tab_set VALUES(&#x27;a,c,d&#x27;);\n\n\n其他\nbinary和varbinary用于保存较短的二进制\nenum用于保存枚举\nset用于保存集合\n\n\n\n日期型\n分类\n\ndate只保存日期；\ntime 只保存时间；\nyear只保存年；\ndatetime保存日期+时间；\ntimestamp保存日期+时间；\n\n\n特点\n\n\n\t\t   字节        范围         时区等的影响datetime\t    8\t    1000——9999\t       不受timestamp\t    4\t    1970-2038\t        受\n\n\n举例\n\nCREATE TABLE tab_date(\tt1 DATETIME,\tt2 TIMESTAMP);INSERT INTO tab_date VALUES(NOW(),NOW());SELECT * FROM tab_date;SHOW VARIABLES LIKE &#x27;time_zone&#x27;;SET time_zone=&#x27;+9:00&#x27;;\n\n六大约束\n含义：一种限制，用户限制表中字段。\n分类（六大约束）\nNOT NULL：非空，保证该字段的值不能为空\nDEFAULT：默认，保证该字段有默认值\nPRIMARY KEY：主键，保证该字段的值唯一，且不为空\nUNIQUE：唯一，用于保证该字段的值具有唯一性，可以为空且为空不具有唯一性\nCHECK：检查字段值是否满足条件\nFOREIGN KEY：外键，用于限制两表的关系，添加外键的从表的字段值必须来自主表相应字段中的值\n\n\n添加约束的时间：\n创建表时（CREATE）\n修改表时（ALTER）\n\n\n约束的添加\n列级约束（外键约束无效果，创建表时，放在表的字段名后）\n表级约束（除非空，默认约束外，放在字段名后）\n\n\n语法\n\nCREATE TABLE 表名&#123;\t字段名 字段类型 列级约束,\t字段名 字段类型,\t表级约束&#125;;\n创建表时添加约束\n语法\n\nCREATE TABLE IF NOT EXISTS stuinfo(\tid INT PRIMARY KEY,\tstuname VARCHAR(20),\tsex CHAR(1),\tage INT DEFAULT 18,\tseat INT UNIQUE,\tmajorid INT,\tCONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id));create table 表名(  \t字段名 字段类型 not null,#非空  \t字段名 字段类型 primary key,#主键  \t字段名 字段类型 unique,#唯一  \t字段名 字段类型 default 值,#默认  \tconstraint 约束名 foreign key(字段名) references 主表（被引用列）);注意：  \t\t\t   支持类型\t\t      可以起约束名\t\t\t列级约束\t\t除了外键\t\t     不可以表级约束\t\t除了非空和默认\t  可以，但对主键无效  列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求\n\n\n举例\n\nUSE students;//列级约束DROP TABLE stuinfo;CREATE TABLE stuinfo(\tid INT PRIMARY KEY,#主键\tstuName VARCHAR(20) NOT NULL UNIQUE,#非空\tgender CHAR(1) CHECK(gender=&#x27;男&#x27; OR gender =&#x27;女&#x27;),#检查\tseat INT UNIQUE,#唯一\tage INT DEFAULT  18,#默认约束\tmajorId INT REFERENCES major(id)#外键);CREATE TABLE major(\tid INT PRIMARY KEY,\tmajorName VARCHAR(20));#查看stuinfo中的所有索引，包括主键、外键、唯一SHOW INDEX FROM stuinfo;//表级约束TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo(\tid INT,\tstuname VARCHAR(20),\tgender CHAR(1),\tseat INT,\tage INT,\tmajorid INT,\t\tCONSTRAINT pk PRIMARY KEY(id),#主键\tCONSTRAINT uq UNIQUE(seat),#唯一键\tCONSTRAINT ck CHECK(gender =&#x27;男&#x27; OR gender  = &#x27;女&#x27;),#检查\tCONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键\t);SHOW INDEX FROM stuinfo;\n主键和唯一的区别\t\t保证唯一性  是否允许为空    一个表中可以有多少个   是否允许组合主键\t\t√\t\t\t\t×\t\t\t至多有1个           √，但不推荐唯一\t\t√\t\t\t\t√\t\t\t可以有多个          √，但不推荐\n\n修改表时添加约束\n语法\n\n#添加约束#1、添加列级约束alter table 表名 modify column 字段名 字段类型 新约束;#2、添加表级约束alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;\n\n\n举例\n\nDROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo(\tid INT,\tstuname VARCHAR(20),\tgender CHAR(1),\tseat INT,\tage INT,\tmajorid INT);DESC stuinfo;#1.添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;#2.添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#3.添加主键    #①列级约束    ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;    #②表级约束    ALTER TABLE stuinfo ADD PRIMARY KEY(id);#4.添加唯一    #①列级约束    ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;    #②表级约束    ALTER TABLE stuinfo ADD UNIQUE(seat);#5.添加外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); //删除约束#1.删除非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;#2.删除默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT ;#3.删除主键ALTER TABLE stuinfo DROP PRIMARY KEY;#4.删除唯一ALTER TABLE stuinfo DROP INDEX seat;#5.删除外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;SHOW INDEX FROM stuinfo;\n自增长列\n可以不用手动插入值，系统提供默认的序列值\n\n特点\n\n不用手动插入值，可以自动提供序列值，默认从1开始，步长为1auto_increment_increment如果要更改起始值：手动插入值如果要更改步长：更改系统变量set auto_increment_increment&#x3D;值;\n一个表至多有一个自增长列\n自增长列只能支持数值型\n自增长列必须为一个key\n\n\n举例\n\n\n#一、创建表时设置标识列DROP TABLE IF EXISTS tab_identity;CREATE TABLE tab_identity(\tid INT  ,\tNAME FLOAT UNIQUE AUTO_INCREMENT,\tseat INT ) TRUNCATE TABLE tab_identity;INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#x27;john&#x27;);INSERT INTO tab_identity(NAME) VALUES(&#x27;lucy&#x27;);SELECT * FROM tab_identity;SHOW VARIABLES LIKE &#x27;%auto_increment%&#x27;;SET auto_increment_increment=3;一、创建表时设置自增长列create table 表(\t字段名 字段类型 约束 auto_increment);二、修改表时设置自增长列alter table 表 modify column 字段名 字段类型 约束 auto_increment;三、删除自增长列alter table 表 modify column 字段名 字段类型 约束;\n\nTCL语言Transaction Control Language，事务控制语言\n事务\n事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。\n事务的特性（ACID特性）\n原子性(Atomicity)：一个事务不可再分割，要么都执行要么都不执行\n一致性(Consistency)：一个事务执行会使数据从一个一致状态切换到另外一个一致状态\n隔离性(Isolation)：一个事务的执行不受其他事务的干扰\n持久性(Durability)：一个事务一旦提交，则会永久的改变数据库的数据\n\n\n分类\n隐式事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete\n显式事务：事务具有明显的开启和结束的标记；前提：必须先设置自动提交功能为禁用\n\n\n步骤\n\n步骤1：开启事务set autocommit=0;start transaction;可选的步骤2：编写事务中的sql语句(select insert update delete)语句1;语句2;...步骤3：结束事务commit;提交事务rollback;回滚事务\n\n\n举例SHOW VARIABLES LIKE &#x27;autocommit&#x27;;SHOW ENGINES;#1.演示事务的使用步骤DROP TABLE IF EXISTS account;CREATE TABLE account(\tid INT PRIMARY KEY AUTO_INCREMENT,\tusername VARCHAR(20),\tbalance DOUBLE);INSERT INTO account(username,balance)VALUES(&#x27;张无忌&#x27;,1000),(&#x27;赵敏&#x27;,1000);#开启事务SET autocommit=0;START TRANSACTION;#编写一组事务的语句UPDATE account SET balance = 1000 WHERE username=&#x27;张无忌&#x27;;UPDATE account SET balance = 1000 WHERE username=&#x27;赵敏&#x27;;#结束事务ROLLBACK;#commit;SELECT * FROM account;\n\n事务的并发性(保证事务的隔离性)\n情景：当多个事务同时操作数据库相同数据时，由于没有必要的隔离机制导致出现问题\n主要问题\n脏读： 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。\n不可重复读：对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。\n幻读：对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。\n\n\n解决办法\n\n设置事务隔离级别\n\t\t\t\t\t\t\t脏读\t\t\t不可重复读\t\t  幻读read uncommitted:读未提交     ×                ×              ×        read committed：读已提交      √                ×              ×repeatable read：可重复读     √                √              ×serializable：串行化          √                √              √\n\n\n一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。\n\nOracle 支持的2 种事务隔离级别：READ COMMITED, SERIALIZABLE。Oracle 默认的事务隔离级别为: READ COMMITED\n\nMysql 支持4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ\n\n举例\n\n\n#查看隔离级别select @@tx_isolation;#设置隔离级别set session|global transaction isolation level 隔离级别;#2.演示事务对于delete和truncate的处理的区别SET autocommit=0;START TRANSACTION;DELETE FROM account;ROLLBACK;#3.演示savepoint 的使用SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点SELECT * FROM account;\n\n视图\n含义：虚拟表,和普通表一样使用。mysql5.1版本出现的新特性，是通过表动态生成的数据。\n\n应用场景 +多个地方用到同样的查询结果 +该查询结果使用的sql语句较复杂\n\n视图的好处\n\n重用sql语句\n简化复杂的sql操作，不必知道它的查询细节\n保护数据，提高安全性\n\n\n\n视图的创建\n语法：create view 视图名 as 查询语句;\n举例\n\nSELECT stuname,majorname FROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE &#x27;张%&#x27;;CREATE VIEW v1 ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`;SELECT * FROM v1 WHERE stuname LIKE &#x27;张%&#x27;;\n\n视图的修改\n语法：\ncreate or replace view 视图名 as 查询语句;\nalter view 视图名 as 查询语句;\n\n\n举例\n\nSELECT stuname,majorname FROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE &#x27;张%&#x27;;CREATE VIEW v1 ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`;SELECT * FROM v1 WHERE stuname LIKE &#x27;张%&#x27;;\n\n视图的删除\n语法：drop view 视图1，视图2,…;\n举例\n\nSELECT stuname,majorname FROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE &#x27;张%&#x27;;CREATE VIEW v1 ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`;SELECT * FROM v1 WHERE stuname LIKE &#x27;张%&#x27;;\n\n视图的查看\n语法：\ndesc 视图名;\nshow create view 视图名;\n\n\n\n视图的更新SELECT stuname,majorname FROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`WHERE s.`stuname` LIKE &#x27;张%&#x27;;CREATE VIEW v1 ASSELECT stuname,majornameFROM stuinfo sINNER JOIN major m ON s.`majorid`= m.`id`;SELECT * FROM v1 WHERE stuname LIKE &#x27;张%&#x27;;\n\n\n注意：视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新\n包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all\n常量视图\nSelect中包含子查询\njoin\nfrom一个不能更新的视图\nwhere子句的子查询引用了from子句中的表\n\n\n\n视图与表的区别            关键字\t\t是否占用物理空间\t            使用视图\t    view\t    占用较小，只保存sql逻辑\t 一般用于查询表\t    table\t\t保存实际的数据\t\t   增删改查\n\n变量\n分类\n系统变量(变量由系统定义，不是用户定义，属于服务器层面)\n全局变量(global关键字)\n会话变量 (session关键字)\n\n\n自定义变量\n用户变量\n局部变量\n\n\n\n\n\n系统变量\n语法\n\n//查看所有系统变量show global|【session】variables;//查看满足条件的系统变量show global|【session】 variables like &#x27;%char%&#x27;;//查看指定的系统变量的值select @@global|【session】系统变量名;//为某个系统变量赋值方式一：set global|【session】系统变量名=值;方式二：set @@global|【session】系统变量名=值;\n\n\n举例\n\n#1》全局变量/*作用域：针对于所有会话（连接）有效，但不能跨重启*/#①查看所有全局变量SHOW GLOBAL VARIABLES;#②查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#x27;%char%&#x27;;#③查看指定的系统变量的值SELECT @@global.autocommit;#④为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;#2》会话变量/*作用域：针对于当前会话（连接）有效*/#①查看所有会话变量SHOW SESSION VARIABLES;#②查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#x27;%char%&#x27;;#③查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;#④为某个会话变量赋值SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;SET SESSION tx_isolation=&#x27;read-committed&#x27;;\n\n自定义变量#二、自定义变量/*说明：变量由用户自定义，而不是系统提供的使用步骤：1、声明2、赋值3、使用（查看、比较、运算等）*/#1》用户变量/*作用域：针对于当前会话（连接）有效，作用域同于会话变量*/#赋值操作符：=或:=#①声明并初始化SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;#②赋值（更新变量的值）#方式一：\tSET @变量名=值;\tSET @变量名:=值;\tSELECT @变量名:=值;#方式二：\tSELECT 字段 INTO @变量名\tFROM 表;#③使用（查看变量的值）SELECT @变量名;#2》局部变量/*作用域：仅仅在定义它的begin end块中有效应用在 begin end中的第一句话*/#①声明DECLARE 变量名 类型;DECLARE 变量名 类型 【DEFAULT 值】;#②赋值（更新变量的值）#方式一：\tSET 局部变量名=值;\tSET 局部变量名:=值;\tSELECT 局部变量名:=值;#方式二：\tSELECT 字段 INTO 具备变量名\tFROM 表;#③使用（查看变量的值）SELECT 局部变量名;#案例：声明两个变量，求和并打印#用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM=m+n;SELECT SUM;\n\n用户变量与局部变量对比\t\t作用域\t\t\t定义位置\t\t语法用户变量\t当前会话\t\t会话的任何地方\t\t加@符号，不用指定类型局部变量\t定义它的BEGIN END中 \tBEGIN END的第一句话\t一般不用加@,需要指定类型\n\n存储过程与函数\n说明：都类似与java中的方法，讲一组完成特定功能的逻辑语句包装起来，对外暴露名称\n好处\n提高代码复用性\n简化操作\n减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率\n\n\n\n存储过程\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n创建\n\nCREATE PROCEDURE 存储过程名(参数列表)BEGIN\t存储过程体（一组合法的SQL语句）END注意：1、参数列表包含三部分参数模式  参数名  参数类型举例：in stuname varchar(20)参数模式：in：该参数可以作为输入，也就是该参数需要调用方传入值out：该参数可以作为输出，也就是该参数可以作为返回值inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值2、如果存储过程体仅仅只有一句话，begin end可以省略存储过程体中的每条sql语句的结尾要求必须加分号。存储过程的结尾可以使用 delimiter 重新设置语法：delimiter 结束标记案例：delimiter $\n\n\n调用\n\nCALL 存储过程名(实参列表);举例：调用in模式的参数：call sp1（‘值’）;调用out模式的参数：set @name; call sp1(@name);select @name;调用inout模式的参数：set @name=值; call sp1(@name); select @name;\n\n\n举例\n\n#1.空参列表#案例：插入到admin表中五条记录SELECT * FROM admin;DELIMITER $CREATE PROCEDURE myp1()BEGIN\tINSERT INTO admin(username,`password`) \tVALUES(&#x27;john1&#x27;,&#x27;0000&#x27;),(&#x27;lily&#x27;,&#x27;0000&#x27;),(&#x27;rose&#x27;,&#x27;0000&#x27;),(&#x27;jack&#x27;,&#x27;0000&#x27;),(&#x27;tom&#x27;,&#x27;0000&#x27;);END $#调用CALL myp1()$#2.创建带in模式参数的存储过程#案例1：创建存储过程实现 根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN\tSELECT bo.*\tFROM boys bo\tRIGHT JOIN beauty b ON bo.id = b.boyfriend_id\tWHERE b.name=beautyName;END $#调用CALL myp2(&#x27;柳岩&#x27;)$#案例2 ：创建存储过程实现，用户是否登录成功CREATE PROCEDURE myp3(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN\tDECLARE result VARBINARY(20) DEFAULT &#x27;&#x27;;#声明并初始化\t\tSELECT COUNT(*) INTO result#赋值\tFROM admin\tWHERE admin.username = username\tAND admin.password = PASSWORD;\t\tSELECT result;#使用END $CALL myp3(&#x27;张飞&#x27;,&#x27;8888&#x27;)$CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))BEGIN\tDECLARE result INT DEFAULT 0;#声明并初始化\t\tSELECT COUNT(*) INTO result#赋值\tFROM admin\tWHERE admin.username = username\tAND admin.password = PASSWORD;\t\tSELECT IF(result&gt;0,&#x27;成功&#x27;,&#x27;失败&#x27;);#使用END $#调用CALL myp4(&#x27;张飞&#x27;,&#x27;8888&#x27;)$#3.创建out 模式参数的存储过程#案例1：根据输入的女神名，返回对应的男神名CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN\tSELECT bo.boyname INTO boyname\tFROM boys bo\tRIGHT JOIN\tbeauty b ON b.boyfriend_id = bo.id\tWHERE b.name=beautyName ;\tEND $#案例2：根据输入的女神名，返回对应的男神名和魅力值CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN\tSELECT boys.boyname ,boys.usercp INTO boyname,usercp\tFROM boys \tRIGHT JOIN\tbeauty b ON b.boyfriend_id = boys.id\tWHERE b.name=beautyName ;\tEND $#调用CALL myp7(&#x27;小昭&#x27;,@name,@cp)$SELECT @name,@cp$#4.创建带inout模式参数的存储过程#案例1：传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN\tSET a=a*2;\tSET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$\n\n\n查看\n\nshow create procedure 存储过程名;\n\n删除\n\ndrop procedure 存储过程名;\n函数\n含义：一组预先编译好的SQL语句的集合，理解成批处理语句\n创建语法\n\nCREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN\t函数体END/*注意：1.参数列表 包含两部分：参数名 参数类型2.函数体：肯定会有return语句，如果没有会报错如果return语句没有放在函数体的最后也不报错，但不建议return 值;3.函数体中仅有一句话，则可以省略begin end4.使用 delimiter语句设置结束标记*/DELIMITER $\n\n\n调用语法\nSELECT 函数名(参数列表);\n\n\n举例\n\nuse employees $#1.无参有返回#案例：返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGIN\t\tDECLARE c INT DEFAULT 0;\tSELECT COUNT(*) INTO c\tFROM employees;\tRETURN c;END $SELECT myf1()$#2.有参有返回#案例1：根据员工名，返回它的工资CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN\tSET @sal=0;#定义用户变量 \tSELECT salary INTO @sal   #赋值\tFROM employees\tWHERE last_name = empName;\t\tRETURN @sal;END $SELECT myf2(&#x27;kochhor&#x27;) $#案例2：根据部门名，返回该部门的平均工资CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLEBEGIN\tDECLARE sal DOUBLE ;\tSELECT AVG(salary) INTO sal\tFROM employees e\tJOIN departments d ON e.department_id = d.department_id\tWHERE d.department_name=deptName;\tRETURN sal;END $SELECT myf3(&#x27;IT&#x27;)$\n\n\n查看函数\n\nshow create function 函数名;\n\n删除函数\n\ndrop function 函数名;\n流程控制结构\n顺序结构：程序从上往下依次执行\n分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行\n循环结构：程序满足一定条件下，重复执行一组语句\n\n分支结构\nif函数\n\n语法：if(条件，值1，值2)\n功能：实现双分支\n应用 ：可以作为表达式放在任意位置\n\n\ncase结构\n\n语法\n\n\n\n情况1：类似于switch，一般用于实现等值判断。语法：case 变量或表达式when 值1 then 语句1;when 值2 then 语句2;...else 语句n;end 情况2：类似于多重if语句，一般用于实现区间判断。语法：case when 条件1 then 语句1;when 条件2 then 语句2;...else 语句n;end \n\n\n特点\n\n可以作为表达式，嵌套在其他语句中使用\nELSE可以省略，如果省略，则所有条件不满足时，为null\n\n\n位置\n\n可以放在任何位置\n放在begin end 外面，作为表达式结合其他语句使用\n放在begin end 里面，一般作为独立语句使用\n\n\n\n\n举例\n#案例 #创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩：90-100, 显示A，80-90，显示B，60-80，显示c，否则，显示DCREATE PROCEDURE test_case (IN score INT) BEGIN \tCASE \tWHEN score&gt;=90 AND score&lt;=100 THEN SELECT &#x27;A&#x27;; \tWHEN score&gt;=80 THEN SELECT &#x27;B&#x27;;\tWHEN score&gt;=60 THEN SELECT &#x27;C&#x27;; \tELSE SELECT &#x27;D&#x27;;\tEND CASE; END $CALL test_case(95)$\n\nif结构\n\n语法if 条件1 then 语句1;elseif 条件2 then 语句2;....else 语句n;end if;\n\n\n特点：类似于多重if，只能放在begin end中\n\n举例\n#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回DCREATE FUNCTION test_case(score FLOAT) RETURNS CHARBEGIN \tDECLARE ch CHAR DEFAULT &#x27;A&#x27;;\t\tCASE \tWHEN score&gt;90 THEN SET ch=&#x27;A&#x27;;\tWHEN score&gt;80 THEN SET ch=&#x27;B&#x27;;\tWHEN score&gt;60 THEN SET ch=&#x27;C&#x27;;\tELSE SET ch=&#x27;D&#x27;;\tEND CASE;\t\tRETURN ch;END $SELECT test_case(56)$\n\n循环结构\n位置：只能在begin end中\n语法\n\n控制语句:leave 名称   类似于breakiterate 名称  类似于continue1、while语法：【名称:】while 循环条件 do\t\t循环体end while 【名称】;2、loop语法：【名称：】loop\t\t循环体end loop 【名称】;3、repeat语法：【名称:】repeat\t\t循环体until 结束条件 end repeat 【名称】;\n\n\n对比\n\n①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称②loop 一般用于实现简单的死循环while 先判断后执行repeat 先执行后判断，无条件至少执行一次\n\n\n举例\n\n#1.没有添加循环控制语句#案例：批量插入，根据次数插入到admin表中多条记录USE girls$DROP PROCEDURE pro_while1$CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN\tDECLARE i INT DEFAULT 1;\tWHILE i&lt;=insertCount DO\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT(&#x27;Rose&#x27;,i),&#x27;666&#x27;);\t\tSET i=i+1;\tEND WHILE;\tEND $CALL pro_while1(158)$select * from admin $/*int i=1;while(i&lt;=insertcount)&#123;\t//插入\ti++;&#125;*/#2.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN\tDECLARE i INT DEFAULT 1;\ta:WHILE i&lt;=insertCount DO\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT(&#x27;xiaohua&#x27;,i),&#x27;0000&#x27;);\t\tIF i&gt;=20 THEN LEAVE a;\t\tEND IF;\t\tSET i=i+1;\tEND WHILE a;END $CALL test_while1(100)$select * from admin $#3.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN\tDECLARE i INT DEFAULT 0;\ta:WHILE i&lt;=insertCount DO\t\tSET i=i+1;\t\tIF MOD(i,2)!=0 THEN ITERATE a;\t\tEND IF;\t\t\t\tINSERT INTO admin(username,`password`) VALUES(CONCAT(&#x27;xiaohua&#x27;,i),&#x27;0000&#x27;);\t\t\tEND WHILE a;END $CALL test_while1(100)$/*int i=0;while(i&lt;=insertCount)&#123;\ti++;\tif(i%2==0)&#123;\t\tcontinue;\t&#125;\t插入&#125;*/select * from admin $\n\n"},{"title":"java日期格式","url":"/2023/04/23/java%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F/","content":"常用格式为：yyyy-MM-dd HH:mm:ss以 2019-12-31 06:07:59:666 时间为例： \n\n\n\nLetter\n含义\nExample\n\n\n\ny\n年\nyyyy——&gt;2019\n\n\nM\n月\nMM——-&gt;12 大写的M\n\n\nd\n一月中的天数\ndd———&gt;31\n\n\nH\n小时(0-23)\nHH———&gt;18   24 小时制的是大写的H\n\n\nh\n小时(1-12）\nhh ———-&gt;06  24 小时制的是大写的h\n\n\nm\n分\nmm——–&gt;07 小写的m\n\n\ns\n秒\nss——–&gt;59\n\n\nS\n毫秒\nSSS———&gt;666\n\n\nY\nWeek of Year\nYYYY—-&gt;2020\n\n\nD\n一年中天数\nDD——–&gt;365\n\n\n 而yyyy-MM-dd与YYYY-MM-dd区别在哪里？Y 代表 Week Year，表示当天周所在的年份。这种方式将会把一年划分成52 周&#x2F;53周（类似于闰年的概念，每隔几年将会增加一周）。Week Year下每周仅属于某一年，如果某年的第一周或最后一周跨年，就会导致部分日期年份与实际不符。\n Week Year 存在两种标准：ISO 8601：国际标准，每周从周一开始，每年的第一周至少包含 4 天Common：通用标准，每周从周日开始，每年的第一周至少包含 1 天\n使用 ISO 8601 标准，分别看一下最后一周跨年以及第一周跨年的例子。2015 年最后一周跨年，2016 前三天（与2015年12月的前四天默认是一周，是2015的周）使用 YYYY 最后结果为 2015，时间看起来被回退了。2020 年第一周跨年，2019 年最后两天（不足4天，所以默认为下周，下周为2020年的周）使用 YYYY 结果为 2020。\n\n总结：\njava中的的日期格式为:\nyyyy-MM-dd HH:mm:ss:代表将时间转换为24小时制,例: 2020-01-07 13:21:55yyyy-MM-dd hh:mm:ss: 代表将时间转换为12小时制,例: 2020-01-07  03:24:21\noracle中的日期格式为(不区分大小写):\nyyyy-MM-dd HH24:mi:ss：代表oracle中的24小时制,例：2020&#x2F;1&#x2F;7 13:21:55yyyy-MM-dd HH:mi:ss：    代表oracle中的12小时制,例：2020&#x2F;1&#x2F;7 9:21:55\n之所以 oracle和java不同,是因为我们知道oracle是不区分大小写的,所以java中根据大小写来代表24小时和12小时的表达式在oracle中就会出问题,oracle中将24小时的时和分做了特殊处理.如上所示,在hh后面加上了24,将mm改为了mi.\n\n版权声明：本文为CSDN博主「37358143」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_37358143/article/details/103868657\n","categories":["java"],"tags":["java"]},{"title":"git 删除远程文件","url":"/2021/07/31/git-%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6/","content":"#--cached不会把本地的文件删除git rm -r --cached .vscode  git commit -m &#x27;delete .vscode&#x27;git push\n","categories":["常用技巧"],"tags":["常用技巧"]},{"title":"Hello World","url":"/2023/04/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"jd脚本部署","url":"/2021/07/27/jd%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2/","content":"jd脚本部署方法本地部署(window系统为例)\n部署node环境\n\nNode.js 环境 下载地址 ，根据自己的操作系统下载和安装。\n\n下载脚本代码\n\n下载地址\n\n安装依赖并配置cookie\n安装依赖压缩包解压后进入项目文件夹\n\nWindows 用户按住 shift 点击右键，点击 在此处打开命令窗口\nMac 用户通过终端，自行进入该文件夹\n\n在命令行内输入 npm i ，等待运行完成。此时，项目文件夹内会多出一个 node_modules文件夹\n\n配置cookie打开项目文件内的 jdCookie.js在最上面的 CookieJDs里写入 cookie ，多个账号以逗号分隔例如\nlet CookieJDs = [  &#x27;pt_key=xxx;pt_pin=xxx;&#x27;,   &#x27;pt_key=zzz;pt_pin=zzz;&#x27;,  &#x27;pt_key=aaa;pt_pin=xxxaaa&#x27;]\n\n\n注：获取京东 cookie 教程参考 浏览器获取京东cookie教程 , 插件获取京东cookie教程还可在项目文件夹下打开命令行工具输入 node getJDCookie.js 扫码获取cookie(推荐)\n\n\n在项目文件夹下打开命令行工具输入node 脚本名 即可运行for example : node jd_bean_change.js可以按TAB键自动补全\n\n\n\n\n云函数部署\n将最新的脚本仓库 fork到自己仓库中\n\n\n\n在腾讯云函数中开通服务依次登录 SCF 云函数控制台 和 SLS 控制台 开通相关服务，确保账户下已开通服务并创建相应服务角色 SCF_QcsRole、SLS_QcsRole\n\n注意！为了确保权限足够，获取这两个参数时不要使用子账户！此外，腾讯云账户需要实名认证。\n\n\n在腾讯云函数中新建访问密钥新建密钥(能通过github工作流部署到腾讯云函数上)将SecretId和SecretKey分别配置在仓库的secrets变量里面， TENCENT_SECRET_ID对应你的SecretId的值，TENCENT_SECRET_KEY对应你的SecretKey的值\n\n配置自己需要的secrets变量参考这里\n目前因为云函数改版升级，原GitHub Action部署云函数方案需要作出相应调整，secret变量新增SCF_REGION和TENCENT_FUNCTION_NAME。SCF_REGION用于控制部署区域的选择，具体参数代码填写可以自行查找官方说明 地域和可用区 TENCENT_FUNCTION_NAME用于控制部署到云函数后函数名的命名。\n\n例SCF_REGION :ap-hongkong\n\n\n\n配置index.js中secrets变量说明\n现在可以通过secret设置自定义index.js中的执行方式，环境变量分别为TENCENTSCF_SOURCE_TYPE和TENCENTSCF_SOURCE_URL，其中TENCENTSCF_SOURCE_TYPE值可以选取local、git、custom具体含义参考这里。TENCENTSCF_SOURCE_URL格式为包含raw的URL，例如：https://raw.githubusercontent.com/LXK9301/jd_scripts/master/或https://gitee.com/lxk0301/jd_scripts/raw/master/\n\n一般默认选择 local方式\n\n\n\n执行action workflow进行部署，workflow未报错即部署成功点击自己仓库下fork的脚本,点击Actions选择Workflows中的部署到腾讯云函数进行部署如果没有看到此按钮,则切换该脚本仓库分支到master!!!!\n\n注意配置secrets变量时,助力码单个账号用@相连接,多个账号用&amp;相互连接!!!!部署成功后,先看自己腾讯云函数那边的环境变量跟自己在仓库配置的 secrets 是否一致\n\n\nDocker部署","categories":["jd"],"tags":["教程","jd"]},{"title":"jd青龙配置教程","url":"/2021/08/09/jd%E9%9D%92%E9%BE%99%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","content":"初始环境不在此教程范围内:包括服务器的配置、dockerd的安装等青龙面板的配置1.安装青龙面板docker run -dit \\  -v $PWD/ql/config:/ql/config \\     #-v 为映射目录到宿主机  -v $PWD/ql/log:/ql/log \\  -v $PWD/ql/db:/ql/db \\  -v $PWD/ql/repo:/ql/repo \\  -v $PWD/ql/raw:/ql/raw \\  -v $PWD/ql/scripts:/ql/scripts \\  -v $PWD/ql/jbot:/ql/jbot \\+ -v $PWD/ql/ninja:/ql/ninja \\  -p 5700:5700 \\        #-p 开启端口 5700默认为青龙面板，5701默认为ninja面板+ -p 5701:5701 \\  --name qinglong \\     #容器名  --hostname qinglong \\    --restart unless-stopped \\  whyour/qinglong:latest \n\n等待安装完成。。。。\n\n重置密码\n\n安装完全后，在浏览器输入ip:5700登录青龙面板\n用户名为admin 密码是 adminadmin\n登录成功后会重置密码，在部署的映射文件$PWD/ql/config/找到auth.json查看重置密码\n2.面板初始配置(拉库,cookie,环境变量配置等)\n在定时任务栏中拉取脚本库\n\n\n这里推荐使用命令\n\nql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git &quot;jd_|jx_|gua_|jddj_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|ZooFaker_Necklace.js|JDJRValidator_Pure|sign_graphics_validate&quot;\n\n时间随意设置\n\n在环境变量栏中添加cookie\n\n这里推荐这样填写\n\n配置文件请按需修改\n\n\n可以看脚本注释写入相应的脚本所需变量脚本中需要的变量使用 export 变量名&#x3D; 声明即可\n\n\n至此青龙面板的初步配置已经结束\n进阶配置TgBot配置\n需要代理或者海外服务器！！！！！！！！\n\n\n1.打开面板界面\n打开配置文件，修改AutoStartBot参数为true;\n\n配置bot.json参数\n\n\n点击右上角\n\n&#123;    &quot;//&quot;: &quot;//开头的的都是注释，不要动，剩下的都按要求改自己的&quot;,    &quot;//user_id&quot;: &quot;↓↓↓  USERID， ↓↓↓&quot;,    &quot;user_id&quot;: ,    &quot;//bot_token&quot;: &quot;↓↓↓  TOKEN  ↓↓↓&quot;,    &quot;bot_token&quot;: &quot;&quot;,    &quot;//api_id&quot;: &quot;↓↓↓  &lt;https://my.telegram.org&gt; 在该网站申请到的id  ↓↓↓&quot;,    &quot;api_id&quot;: &quot;&quot;,    &quot;//api_hash&quot;: &quot;↓↓↓  &lt;https://my.telegram.org&gt; 在该网站申请到的hash  ↓↓↓&quot;,    &quot;api_hash&quot;: &quot;&quot;,    &quot;//proxy&quot;: &quot;↓↓↓  使用代理改成true，不使用下方带proxy的不用动  ↓↓↓&quot;,    &quot;proxy&quot;: false,    &quot;//proxy_type&quot;: &quot;↓↓↓  socks5 或者 http 或者 MTProxy ↓↓↓&quot;,    &quot;proxy_type&quot;: &quot;socks5&quot;,    &quot;//proxy_add&quot;: &quot;↓↓↓  代理IP地址例如：192.168.99.100  ↓↓↓&quot;,    &quot;proxy_add&quot;: &quot;192.168.99.100&quot;,    &quot;//proxy_port&quot;: &quot;↓↓↓  代理端口，不需要双引号例如 5890  ↓↓↓&quot;,    &quot;proxy_port&quot;: 5890,    &quot;//proxy_secret&quot;: &quot;↓↓↓  如果使用MTProxy，填入MTProxy代理秘钥  ↓↓↓&quot;,    &quot;proxy_secret&quot;: &quot;&quot;,    &quot;//proxy_user&quot;: &quot;↓↓↓  代理的username,有就改，没有就不要动  ↓↓↓&quot;,    &quot;proxy_user&quot;: &quot;代理的username,有则填写，无则不用动&quot;,    &quot;//proxy_password&quot;: &quot;↓↓↓  代理的密码,有则填写，无则不用动  ↓↓↓&quot;,    &quot;proxy_password&quot;: &quot;代理的密码,有则填写，无则不用动&quot;,    &quot;//StartCMD&quot;: &quot;↓↓↓ 是否开启CMD命令，开启改成true  ↓↓↓&quot;,    &quot;StartCMD&quot;: true,    &quot;//noretry&quot;: &quot;↓↓↓ 是否 关闭 bot掉线重连，默认开启，关闭改成true  ↓↓↓&quot;,    &quot;noretry&quot;: false&#125;\n\n\n\n2.申请bot\n打开tg，搜索botfather，按照提示申请自己的bot\n获取bot的token\n搜索getmyid_bot 获取user_id\n获取api_id和api_hash，打开https://my.telegram.org/，随意填写名字后出现App title：abcdeShort name：abcde123\n将上述步骤获取的数据填入bot.json\n\n3.重启botdocker exec -it 容器名 ql bot\n\n\n\n\n至此bot配置结束，如果bot无响应，可以在面板的日志的查看bot日志，解决相应问题\n脚本相关依赖库基本依赖\ndocker exec -it 容器名 bash -c &quot;npm install -g typescript&quot;docker exec -it 容器名 bash -c &quot;npm install axios date-fns&quot;docker exec -it 容器名 bash -c &quot;npm install png-js&quot;docker exec -it 容器名 bash -c &quot;npm install -g npm&quot;docker exec -it 容器名 bash -c &quot;pnpm i png-js&quot;docker exec -it 容器名 bash -c &quot;pip3 install requests&quot;docker exec -it 容器名 bash -c &quot;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; cd scripts &amp;&amp; npm install canvas --build-from-source&quot;docker exec -it 容器名 bash -c &quot;apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev&quot;docker exec -it 容器名 bash -c &quot;cd /ql/scripts/ &amp;&amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; npm i &amp;&amp; npm i -S ts-node typescript @types/node date-fns axios png-js canvas --build-from-source&quot;\n\n\n\n签到，宠汪汪兑换等依赖文件安装\ncd /ql/scriptswget https://ghproxy.com/https://github.com/shufflewzc/faker2/releases/download/0.0.1/utils.zip &amp;&amp; unzip utils.zip\n\n\n\n可以通过查看日志方式，安装缺失的依赖\ndocker exec -it 容器名 npm install ***  #***为依赖名\n\n\n\n\n\n\n\n互助1.添加code.sh\n代码见下方 \n\n编辑好文件，放入&#x2F;ql&#x2F;config映射目录下，并添加定时脚本，可启用定时，可不启用定时name_js参数根据你所执行的脚本前缀进行修改\n2.加入助力运行code.sh，将获取得到的输出添加到配置文件的task_before.sh里\n对于非常规的助力，需要进入脚本查看注释获得相应的助力方法\n","categories":["jd"],"tags":["教程","jd"]},{"title":"查看电脑开机时间","url":"/2021/07/27/%E6%9F%A5%E7%9C%8B%E7%94%B5%E8%84%91%E5%BC%80%E6%9C%BA%E6%97%B6%E9%97%B4/","content":"方式一cmd命令下运行\n$ net statistics workstation\n\n或者\n$ systeminfo\n\n方式二 通过事件查看器查看\n打开计算机事件查看器： 开始》管理工具》事件查看器》windows 日志》应用程序》查看日期\n\n来源为rvice User profile se ID 为1531 常规说明“已成功启动用户配置文件服务”此为开机记录。\n\n来源为rvice User profile se ID 为1532 常规说明“已停止用户配置文件服务”此为关机记录。如果中途注销了电脑同样有这样的记录，但看记录时间你就能看得出来。\n\n\n或者\n\n打开计算机事件查看器： 开始》管理工具》事件查看器》windows 日志》系统，然后选择打开右边的“筛选当前日记”， 在“筛选当前日志”窗口中，事件来源选择“eventlog”，在如下图位置输入“6005,6006”。\n输好后点击确定，在主要窗口就会筛选出电脑最近时间的开机关机情况。\n\n","categories":["常用技巧"],"tags":["常用技巧"]}]